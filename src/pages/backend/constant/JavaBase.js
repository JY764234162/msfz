export default [
  {
    title: "Java基础 --- 1、变量的作用域",
    content: `
     局部变量：在方法、构造器或者块语句中定义的变量，其作用域仅限于该方法、构造器或块内部。
     类变量（静态变量）：用static修饰的变量，属于类级别，只有一份存储空间，所有类的实例共享这个变量。
     实例变量（成员变量）：在类中定义，但不在任何方法内的变量，每个类实例都有自己的一份拷贝。
      `,
  },
  {
    title: "Java基础 --- 2、变量的生命周期",
    content: `
      - 局部变量：随着方法调用结束而销毁。
      - 实例变量：随着对象的创建而存在，随着对象变为垃圾而被回收。
      - 类变量（静态变量）：当类被加载时初始化，直到类被卸载才会消失。
      `,
  },
  {
    title: "Java基础 --- 3、 变量的初始化",
    content: `
      - 局部变量必须初始化才能使用，否则编译器会报错。
      - 实例变量和类变量（静态变量）则不需要在声明时初始化，它们会被赋予默认值（如0、null、false等），但在使用前最好显式初始化。
      `,
  },
  {
    title: "Java基础 --- 4、数据类型分类",
    content: `
      1、基本数据类型：包括整型（byte, short, int, long）、浮点型（float, double）、字符型（char）、布尔型（boolean）。
      2、引用数据类型：包括类（Class）、接口（Interface）、数组（Array）。
      `,
  },
  {
    title: "Java基础 --- 5、基本数据类型的大小、取值范围以及默认值 ",
    content: `
       - byte：8位，-128~127，默认值为0。
       - short：16位，-32768~32767，默认值为0。
       - int：32位，-2^31~2^31-1，默认值为0。
       - long：64位，-2^63~2^63-1，默认值为0L。
       - float：32位单精度浮点数，默认值为0.0f。
       - double：64位双精度浮点数，默认值为0.0d。
       - char：16位Unicode字符，\u0000~\uffff，默认值为'\u0000'。
       - boolean：表示逻辑值，只有true和false两个值，默认值为false。
      `,
  },
  {
    title: "Java基础 --- 6、 面向对象",
    content: `
      1. 封装
         封装是指将对象的状态（属性）和行为（方法）封装在一起，对外部隐藏对象的内部实现细节，只暴露必要的接口供外部访问。这样可以提高代码的安全性和可靠性，同时简化外部调用者与对象之间的交互，降低耦合度。

      2. 继承
         继承是指一个类（子类）可以继承另一个类（父类）的属性和方法，子类可以重用父类的代码并且可以在其基础上进行扩展和修改。通过继承，可以实现代码的复用，提高代码的可维护性和可扩展性。

      3. 多态
         多态是指同一个方法可以根据调用者的不同而表现出不同的行为。在面向对象编程中，多态可以通过继承和接口实现，使得不同类的对象可以以统一的方式进行操作，提高了代码的灵活性和可扩展性。
      `,
  },
  {
    title: "Java基础 --- 7、 抽象类和接口的区别与联系",
    content: `
      抽象类（Abstract Class）：
      抽象类是Java中一种不能被实例化的类，使用'abstract'关键字进行声明。抽象类可以包含抽象方法（只有方法签名没有方法体的方法）和非抽象方法（具有具体实现的方法）。抽象类的主要目的是为了被其他类继承，它的子类必须实现抽象类中所有的抽象方法。抽象类可以包含变量（实例变量或静态变量）和构造方法，可以为子类提供共性方法的实现。

      接口（Interface）：
      接口同样不能被实例化，它代表一种契约，定义了一组方法签名，所有实现该接口的类都必须提供这些方法的实现。在Java 8之前，接口中的方法默认都是抽象的，不提供实现。Java 8及以后版本中，接口还可以包含默认方法（default methods）和静态方法，这两种方法都有具体的实现。接口中的变量默认是静态和最终的（static final），即常量。

      区别：

      1. 抽象类可以有构造方法，而接口不能有构造方法。
      2. 抽象类中可以有非抽象方法（即具体实现的方法），而接口中只能有抽象方法（在Java 8之前）。
      3. 一个类只能继承一个抽象类，但可以实现多个接口（Java 8之前）。Java 8引入了多重继承的功能，接口可以继承其他接口，一个类也可以通过实现多个接口来间接实现多重继承的效果。
      4. 抽象类可以包含实例变量，而接口中的变量默认是静态的、最终的常量。
      5. 抽象类允许使用protected、public、private访问修饰符来控制成员的可见性，而接口中的成员默认为public，从Java 9开始，接口中也可以使用private方法。

      联系：

      1. 抽象类和接口都是为了实现代码复用和面向对象设计原则中的多态性。
      2. 抽象类和接口都可以包含抽象方法，要求子类或实现类去实现这些方法。
      3. 在设计层面，抽象类通常用于定义一个类族的共性，而接口强调的是实现类之间的共同行为或责任。
      `,
  },
  {
    title: "Java基础 --- 8、 如何选择使用抽象类还是接口",
    content: `
      场景示例：
      假如你要设计一个图形处理软件，其中包含圆形、矩形等各种形状。所有形状都有颜色、绘制、尺寸等共性特征，但绘制方法的具体实现各不相同。这时，你可以定义一个抽象类'Shape'，包含共性的成员变量和方法，如'getColor()'、'setDimension()'等，而绘制方法'draw()'则声明为抽象方法。各个具体的形状类如'Circle'、'Rectangle'等继承'Shape'并实现'draw()'方法。

      另一种情况，如果图形软件需要新增一个可拖拽功能，该功能不是所有形状都必须具备的，而是部分形状可以选择实现的附加功能。此时，你可以定义一个'Draggable'接口，包含'startDragging()'、'drag()'和'stopDragging()'方法。然后，那些需要实现拖拽功能的形状类（如'Circle'、'Rectangle'等）可以选择实现'Draggable'接口，提供拖拽功能的实现。
      `,
  },
  {
    title: "Java基础 --- 9、 什么是Java内部类？为什么我们需要使用内部类？",
    content: `
      内部类是在一个类的内部定义的类，它可以访问外部类的所有成员（包括私有成员）。内部类提供了更好的封装性和更强的关联性，使得我们可以将一些逻辑相关的类组织在一起，同时可以根据需要隐藏内部类的实现细节，提高代码的内聚性。
      `,
  },
  {
    title: "Java基础 --- 10、 内部类有哪些种类",
    content: `
      - 在Java中，内部类主要有以下几种类型：
     - 成员内部类（Member Inner Class）：定义在外部类的成员位置上，可以访问外部类的所有成员。
     - 静态内部类（Static Nested Class）：使用static关键字修饰的内部类，不需要外部类实例就可以创建对象，不能直接访问外部类的非静态成员。
     - 局部内部类（Local Inner Class）：定义在方法、代码块或者构造器内部的类，只在其所在作用域有效。
     - 匿名内部类（Anonymous Inner Class）：没有名字的内部类，一般用来简化单例实现或者事件监听器等场景下的代码。
      `,
  },
  {
    title: "Java基础 --- 11、枚举有哪些特点 ",
    content: `
       - 枚举类型在编译时就确定了所有可能的值，提供了类型安全。
       - 枚举类型天然地实现了Comparable接口和Serializable接口。
       - 枚举类型可以拥有方法和变量，可以实现接口。
       - 枚举类型的所有实例都在第一次加载时创建，因此它们是单例的。
      `,
  },
  {
    title: "Java基础 --- 12、 异常处理机制",
    content: `
      Java异常处理机制是Java提供的一种错误处理机制，它通过try、catch、finally和throw等关键字来处理程序运行过程中可能出现的错误情况。当程序运行时发生异常，异常处理机制可以捕获并处理这些错误，从而确保程序的健壮性和稳定性。
      `,
  },
  {
    title: "Java基础 --- 13、异常类层次结构",
    content: `
      Java中的所有异常类都继承自java.lang.Throwable类，Throwable有两个直接子类：Error和Exception。Error类通常指Java虚拟机自身无法处理的严重错误，如系统崩溃、虚拟机错误等。Exception类则包含了程序运行时可以捕获和处理的异常，它又分为两大类：Checked Exception（受检异常）和Unchecked Exception（非受检异常，也称为运行时异常），受检异常需要在方法签名中通过throws声明或在方法内部捕获处理，非受检异常则可以在运行时被捕获处理，但不是必须的。
      `,
  },
  {
    title: "Java基础 --- 14、 throw和throws关键字的区别",
    content: `
        - throw：关键字用于在方法体内部手动抛出一个异常对象，中断当前方法的执行流程。
        - throws：关键字用于声明方法可能抛出的异常列表，这些异常需要由方法的调用者来处理。在方法声明后面跟上throws关键字和异常列表。
      `,
  },
  {
    title: "Java基础 --- 15、 字节流与字符流的区别",
    content: `
      1、字节流（Byte Stream）：操作的基本单元是字节（8位），如InputStream和OutputStream家族，主要用于处理二进制数据，如图像、音频、视频等非文本文件。
      2、字符流（Character Stream）：操作的基本单元是字符（通常是16位的Unicode字符），如Reader和Writer家族，主要用于处理文本数据，它会自动处理字符编码转换，如从字节流中读取数据并解码为字符。
      `,
  },
  {
    title: "Java基础 --- 16、缓冲流的作用",
    content: `
      缓冲流是对原始流的包装，它增加了缓冲功能，可以一次性读取或写入多个字节或字符，减少系统I/O操作次数，提高数据读写效率。例如，BufferedReader和BufferedWriter是针对字符流的缓冲，而BufferedInputStream和BufferedOutputStream是针对字节流的缓冲。
      `,
  },
  {
    title: "Java基础 --- 17、文件操作常见类",
    content: `
      1、File类：用于表示文件和目录路径，可以进行文件或目录的创建、删除、重命名等操作。
      2、FileReader和FileWriter：用于读写文件内容，它们是字符流，内部会隐含使用FileInputStream和FileOutputStream。
      3、FileInputStream和FileOutputStream：用于读写文件的字节流。
      `,
  },
  {
    title: "Java基础 --- 18、NIO（New I/O）体系",
    content: `
      1、通道（Channel）：是NIO的核心组件，用于在应用程序和操作系统之间高效地传输数据。它可以从文件、网络连接等来源获取数据，也可以向这些目标发送数据。
      2、缓冲区（Buffer）：是NIO用来存储和管理数据的地方，它在内存中开辟一片区域，提供了数据的读写功能，相比于传统I/O的每次读写一个字节或字符，NIO的缓冲区可以批量读写数据，从而提高效率。
      3、选择器（Selector）：在NIO中，选择器用于检测一个或多个通道的状态变化，如是否准备好进行读写操作。它使得单个线程可以监控多个通道，从而实现多路复用，减少线程上下文切换的开销。
      `,
  },
  {
    title: "Java基础 --- 19、动态代理？",
    content: `
      Java动态代理是一种在运行时创建代理类的技术，无需在编译期就确定代理类。通过Java反射包中的Proxy类和InvocationHandler接口实现。动态代理可以在运行时动态地创建一个实现了一组给定接口的新类，这个新类的行为可以由InvocationHandler的invoke方法来定义，以便在方法调用前后添加额外的操作，如权限校验、日志记录、事务处理等。
      `,
  },
  {
    title: "Java基础 --- 20、动态代理的工作原理",
    content: `
      Java动态代理的工作原理主要包括两部分：
       - Proxy类：Java标准库提供，通过调用其newProxyInstance方法创建代理对象，需要传入ClassLoader、目标类实现的接口数组以及InvocationHandler对象。
       - InvocationHandler接口：自定义实现，它有一个invoke方法，当我们通过代理对象调用方法时，实际上会调用到此invoke方法。在invoke方法内部，可以决定如何调用实际的目标对象的方法，以及在调用前后添加额外的操作。
      `,
  },
  {
    title: "Java基础 --- 21、Java动态代理与CGLIB代理的区别",
    content: `
      Java动态代理基于Java反射API实现，只能对接口进行代理。而CGLIB（Code Generation Library）代理则通过字节码底层技术生成一个继承自目标类的子类来实现代理，因此CGLIB不仅能够代理接口，还可以代理没有实现接口的类。不过，CGLIB需要第三方库支持，并且由于是通过继承的方式进行代理，所以如果目标类是final类或含有final方法，CGLIB将无法进行代理。
      `,
  },
  {
    title: "Java基础 --- 22、注解的生命周期",
    content: `
      Java注解的生命周期由@Retention元注解决定，包括以下三种策略：

       - RetentionPolicy.SOURCE：注解只保留在源代码中，编译器处理后丢弃，不在class文件中保存。
       - RetentionPolicy.CLASS：默认策略，注解保留在class文件中，但在运行时无法访问到。
       - RetentionPolicy.RUNTIME：注解不仅保留在class文件中，而且能在运行时通过反射API读取到。
      `,
  },
  {
    title: "Java基础 --- 23、 反射API的主要用途",
    content: `
       - 动态类加载：根据字符串类名加载相应的Class对象。
       - 获取类信息：获取类的属性、方法、构造器、接口等信息，包括访问私有成员和受保护成员。
       - 创建对象实例：即使没有明确的类引用，也能通过反射创建对象。
       - 方法调用：在运行时调用对象的任意方法，不受编译期限制。
       - 修改对象属性：可以动态地设置或获取对象的属性值，即使属性是私有的。
       - 检查类兼容性：在运行时判断类是否实现了特定接口或继承了某个类。
       - 实现通用代理、框架设计、序列化反序列化、动态编译等高级功能。
      `,
  },
  {
    title: "Java基础 --- 24、什么是Java反射API？",
    content: `
      Java反射API是Java运行时环境提供的内省机制，允许运行中的Java程序对自身或者其他类的结构进行访问和操作，包括获取类的信息（如类名、属性、方法等）、创建对象实例、调用方法、改变字段值等。这种能力使得Java程序能够在运行时动态地发现和操作类及对象的元数据，增强了程序的灵活性和适应性。
      `,
  },
  {
    title: "Java基础 --- 25、 反射API有什么潜在的风险或注意事项？",
    content: `
      - 安全性：反射绕过了正常的访问控制检查，可能导致安全漏洞，例如未经授权访问私有数据或执行私有方法。
   - 性能开销：反射操作比直接的静态方法调用慢很多，因为它涉及到查找和解析类、方法、字段等额外的操作，频繁或不必要的反射调用可能会导致性能下降。
   - 强制转换问题：反射调用可能需要进行强制类型转换，如果不小心可能会抛出ClassCastException异常。
   - 稳定性：过度依赖反射可能会降低代码的稳定性，因为如果类的结构发生变化，而反射代码未及时更新，则可能导致运行时错误。
      `,
  },
  {
    title: "Java基础 --- 26、 new Integer(123) 与 Integer.valueOf(123) 的区别",
    content: `
      new Integer(123) 每次都会新建一个对象
      Integer.valueOf(123)  会使用缓存池中的对象，多次调用会取得同一个对象的引用。
      在 Java 8 中，Integer 缓存池的大小默认为 -128~127。
      `,
  },
  {
    title: "Java基础 --- 27、String 为什么不可变？",
    content: `
       1  可以缓存 hash 值
      因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。

      2 String Pool 的需要
      如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。

      3 安全性
      String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。

      4  线程安全
      String 不可变性天生具备线程安全，可以在多个线程中安全地使用。
      `,
  },
];
