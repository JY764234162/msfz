export default [ 
      { 
          title: "多线程并发 --- 1、 问题：线程的定义和作用",
          content: ` 
          线程的基本定义：线程是操作系统能够进行运算调度的最小单位，它是进程内的一个执行流，是程序中单一顺序的控制流程。
          在一个进程中可以并发地执行多个线程，每个线程都拥有自己的程序计数器（PC，指示下一条要执行的指令地址）、寄存器集合以及栈空间。
          线程不拥有独立的系统资源（如地址空间、打开的文件等），而是共享其所属进程的这些资源，
          但每个线程有自己的线程上下文，包括程序计数器、栈、线程本地存储等。

          线程的作用：
          1. 并发执行：线程允许多个任务在同一进程中并发执行，这意味着即使在单个处理器上，通过操作系统的时间片轮转机制，也可以模拟出“并行”效果，提升程序的执行效率和响应速度。
          2. 资源共享：同一进程中的所有线程可以访问相同的地址空间和其他资源，这样它们可以轻松地共享数据和同步信息，简化编程模型。
          3. 提高系统资源利用率：当一个线程等待I/O操作完成时，其他线程可以继续执行，避免了因单一线程阻塞导致整个进程停滞的情况，提高了系统整体的资源利用率。
          4. 实时响应与高性能计算：在网络服务、GUI应用程序、实时系统、并行计算等领域，线程能帮助程序更好地响应外部事件，同时在多核或多CPU架构上，通过多线程技术可以实现真正的并行计算，显著加快数据处理速度。
          5. 模块化与简化编程：线程使得复杂的应用程序可以分解成多个相对独立且并发执行的任务模块，有利于软件设计、调试和维护。
          总结来说，线程作为操作系统调度的最小单元，通过并发执行多个任务实现了现代操作系统中的并发处理能力，极大地提升了计算机系统的运行效率和服务质量。
           `,
     },
     { 
          title: "多线程并发 --- 2、 问题：并发与并行的概念及其在操作系统中的体现",
          content: ` 
          1、并发 (Concurrency)：	
          并发是指在一段时间内，系统看似同时处理多个任务或者执行多个操作的现象。	
          在操作系统中，即便是在单个处理器或单个CPU核心的情况下，也能通过快速切换上下文（context switching）来实现并发。	
          操作系统将CPU时间划分为非常短的时间片（time slice），然后轮流让不同的任务（进程或线程）使用CPU，这样在宏观上看起来好像所有的任务都在同一时间内执行。	但实际上，微观上每个任务只在特定时间片段里运行，而非真正的同时执行。	例如，在单核系统中，浏览器可以一边下载网页，一边播放音频，虽然CPU在同一个时间点只能执行其中的一个操作，但是通过时间分片的方式，这两个任务在用户看来就像是同时进行的。2、并行 (Parallelism)：	并行则是指在同一时刻，系统确实能够同时执行多个任务或操作。这需要依赖于硬件支持，通常是指有多核CPU或者多个处理器的系统。在这样的环境下，操作系统可以将不同的任务分配给不同的处理器或核心，从而实现在物理层面的真正同时执行。例如，在一个多核CPU的计算机上，一个核心可以运行游戏程序，另一个核心可以处理操作系统服务，这时，两个任务是在同一时刻分别在不同的硬件资源上执行的，这就是并行。总结：- 并发是逻辑上的同时发生，是通过时间片轮转、事件驱动等方式使多个任务交错执行，产生并发效果。- 并行是物理上的同时发生，是利用多处理器或多核结构使得多个任务真正意义上的同时执行。在操作系统中，无论是并发还是并行，都需要有效的调度算法、同步机制和通信手段来协调和管理这些任务，确保它们高效、安全地执行。随着多核CPU的发展，现代操作系统的设计越来越多地结合并发和并行技术来提升系统性能。
           `,
     },
     { 
          title: "多线程并发 --- 3、 问题：使用多线程的原因及优势",
          content: ` 
          1. 提高资源利用率：多线程可以充分利用多核CPU的并行处理能力，当一个线程等待I/O操作或其他外部资源时，其他线程可以继续执行，从而减少CPU空闲时间，提高系统整体性能。
          2. 提高响应速度与实时性：在图形用户界面（GUI）应用中，主线程可以专注于处理用户的交互和界面更新，而将耗时的后台任务放在辅助线程中执行，这样就不会阻塞界面响应，提升用户体验。
          3. 并发处理与提高吞吐量：多线程可实现对并发请求、网络通信、数据处理等任务的并行处理，尤其在服务器和分布式系统中，能有效提高系统处理大量并发事务的能力。
          4. 易于建模与程序结构优化：对于大型复杂的任务，可以将其拆分成多个小任务（子线程），各自独立运行，简化程序设计和维护，同时也有利于代码重用和模块化。
          5. 资源共享与通信方便：同一线程内的各个线程可以共享进程的大部分资源，包括内存空间，这降低了通信成本，简化了数据传递的过程。

          然而，多线程编程也存在相应的挑战：
          1. 线程安全问题：当多个线程同时访问和修改共享资源时，容易出现竞态条件（race condition）、死锁（deadlock）、活锁（livelock）和资源饥饿（resource starvation）等问题，需要采取适当的同步机制（如互斥锁、信号量、条件变量等）来保证数据一致性。
          2. 上下文切换开销：线程切换时需要保存和恢复线程上下文（如寄存器状态、栈信息等），频繁的上下文切换会消耗系统资源，降低总体性能。
          3. 编程复杂度增加：多线程编程要求开发者具备良好的并发编程思维和技巧，以避免各种并发问题的发生，这对程序员的要求较高。
          4. 测试和调试难度增大：由于线程执行的不确定性，多线程程序的错误可能难以复现，增加了调试和测试的复杂性。
          5. 资源竞争与性能瓶颈：若资源竞争过于激烈，同步机制可能会成为新的性能瓶颈，影响程序整体效率。
          因此，在设计和实现多线程应用程序时，需要权衡多线程带来的优势与解决上述挑战所需的额外工作，合理安排线程间的协作和同步策略，以达到最优的程序性能和可靠性。
           `,
     },
     { 
          title: "多线程并发 --- 4、 问题：创建线程",
          content: ` 
          - 继承 Thread 类并重写 run() 方法
          - 实现 Runnable 接口并提供 run() 方法
          - 使用 Callable 和 Future 接口配合 ExecutorService- 线程池（ThreadPoolExecutor）
           `,
     },
     { 
          title: "多线程并发 --- 5、 问题：请解释Java中的Callable与Future接口在多线程编程中的作用及其使用场景？",
          content: ` 
          	Callable接口允许我们创建一个可以返回值并抛出检查型异常的任务对象。
               相比于Runnable，Callable任务可以获取一个泛型化的结果。配合Future接口，我们可以异步获取该任务的结果，并提供取消任务的方法。

               使用场景：
               1、当我们需要从线程中获取一个具体的返回值时，可以选择使用Callable。
               2、使用Future.get()方法可以阻塞当前线程直到Callable任务执行完毕并获取其结果，这对于监控任务执行状态和结果很有用。
               3、若线程执行过程中出现异常，可以通过Future.get()捕获该异常。
               4、Future还提供了取消任务的方法cancel(boolean mayInterruptIfRunning)，可以更加灵活地控制任务的生命周期。
           `,
     },
     { 
          title: "多线程并发 --- 6、 问题：Runnable 和 Callable 区别",
          content: ` 
          1. Runnable 接口：   
          - Runnable 是 Java 中最基本的线程任务接口，它只有一个 void run() 方法，用于定义线程的执行体。   
          - Runnable 对象被传递给 Thread 类的构造函数，然后通过调用 Thread 的 start() 方法来启动线程执行 run() 方法里的代码。   
          - Runnable 不支持返回值，也不能抛出受检异常，如果需要反馈线程执行结果，需要自行定义共享变量或使用第三方库提供的机制。

          2. Callable 接口：   
          - Callable 是比 Runnable 更高级别的接口，它定义了一个 V call() 方法，该方法可以有返回值（类型为泛型 V）并且可以抛出异常。   
          - Callable 任务通常与 Future 和 ExecutorService 结合使用，通过 ExecutorService.submit(Callable) 提交任务后，可以获得一个 Future 对象，通过 Future.get() 方法可以阻塞等待获取 Callable 任务的返回结果，同时也可以检查任务是否已经完成、取消或抛出异常。   
          - 因此，Callable 更适合那些需要获取线程执行结果的场景。总结一下，如果你的任务不需要返回结果，选择 Runnable 就足够了；
          但如果你的任务需要返回一个结果，并且/或者可能抛出异常，那么 Callable 是更好的选择。
           `,
     },
     { 
          title: "多线程并发 --- 7、 问题：什么是Java线程池？为什么使用线程池？",
          content: ` 
          	Java线程池是Java标准库提供的一个工具，通过预先创建一组工作线程来执行提交的任务，而不是每次需要执行任务时创建和销毁线程。
               线程池的核心组件是java.util.concurrent.ExecutorService接口，具体实现类如ThreadPoolExecutor。

               使用线程池的主要原因包括：
               1、资源重用：减少了线程创建和销毁的开销。
               2、统一管理：能够限制系统中并发线程的数量，防止过多线程消耗系统资源。
               3、线程控制：能够设置线程的优先级、超时策略、拒绝策略等，对线程行为进行更精细的控制。
               4、容量规划：通过调整线程池大小，可以应对不同规模的任务负载。
           `,
     },
     { 
          title: "多线程并发 --- 8、 问题：Java中的线程池有哪些种类？",
          content: ` 
          Java中有多种内置线程池实现，包括：
          1、FixedThreadPool：线程池中的线程数量始终保持固定，超过线程池容量的任务会被放入无界队列中等待执行。
          2、CachedThreadPool：线程池中的线程数量可根据需求动态增加，没有预设的线程最大数量，适用于执行大量短生命周期的任务。
          3、SingleThreadExecutor：线程池中只有一个线程，按照先进先出的顺序执行任务。
           `,
     },
     { 
          title: "多线程并发 --- 9、 问题：ThreadPoolExecutor的构造参数有哪些？",
          content: ` 
          ThreadPoolExecutor构造函数接受如下几个核心参数：
          corePoolSize：核心线程数
          maximumPoolSize：最大线程数。
          keepAliveTime：超时时间。
          unit：时间单位。
          workQueue：工作队列，用于存放待执行的任务。
          threadFactory：线程工厂，用于生成新线程，默认情况下使用的是
          DefaultThreadFactory。handler：拒绝策略，当线程池和工作队列均无法接纳新任务时，所采取的策略。
           `,
     },
     { 
          title: "多线程并发 --- 10、 问题：如何关闭线程池？",
          content: ` 
          可以通过调用ThreadPoolExecutor的shutdown()或shutdownNow()方法来关闭线程池。
          shutdown()：不再接收新的任务，但会把已提交的任务执行完。
          shutdownNow()：尝试停止所有正在执行的任务，并放弃等待队列中的任务，返回尚未开始执行的任务列表。
           `,
     },
     { 
          title: "多线程并发 --- 11、 问题：描述一下线程池的工作流程？",
          content: ` 
          线程池的工作流程大致如下：
          1、当提交任务到线程池时，首先检查线程池中的线程数量是否少于核心线程数，如果是，则创建一个新线程来执行任务
          2、如果线程数已经达到核心线程数，且工作队列未满，则将任务添加到工作队列中等待执行。
          3、如果工作队列已满，且线程数未达到最大线程数，则创建新线程执行任务。
          4、当线程池中线程数达到最大线程数，且工作队列已满时，如果还有新的任务提交，则依据拒绝策略处理新任务，比如丢弃任务或抛出异常。

          工作队列
          1. ArrayBlockingQueue   基于数组的有界队列
          2. LinkedBlockingQueue  基于链表的无界队列 , 核心线程数满了之后,会一直存进队列  最大数 Integer
          3. SynchronousQuene  不缓存任务的阻塞队列   生产者放入一个任务就等待消费者取出一个任务;
          4. PriorityBlockingQueue  具有优先级的无界阻塞队列，优先级通过参数Comparator实现。
           `,
     },
     { 
          title: "多线程并发 --- 12、 问题：如何设定线程池的拒绝策略？",
          content: ` 
          Java中提供了四种预设的拒绝策略：
          AbortPolicy：默认拒绝策略，直接抛出RejectedExecutionException异常。
          CallerRunsPolicy：调用者所在线程直接执行任务。
          DiscardPolicy：默默地丢弃掉任务，不做任何处理。
          DiscardOldestPolicy：丢弃队列中最旧的任务，尝试重新提交当前任务。用户还可以自定义拒绝策略，实现RejectedExecutionHandler接口并传给线程池构造函数。
           `,
     },
     { 
          title: "多线程并发 --- 13、 问题：在使用线程池时，如何避免OOM（内存溢出）问题？ 答：为了避免OOM，可以考虑以下几个方面：",
          content: ` 
          1、设置合理的线程池大小，避免因过多线程导致内存消耗过大。
          2、限制工作队列的大小，尤其是对于无界队列（如LinkedBlockingQueue），如果不加以限制，大量任务堆积可能导致内存溢出。
          3、注意任务本身占用的内存资源，确保任务完成后能够及时释放内存。
          4、使用有界队列（如ArrayBlockingQueue），结合合理的拒绝策略，可以防止因队列无限增长而导致内存溢出。
           `,
     },
     { 
          title: "多线程并发 --- 14、 问题：线程池中如何处理线程的异常？",
          content: ` 
          	在ThreadPoolExecutor中，如果线程在执行任务时抛出了未捕获的异常，那么这个异常会被封装成RunnableFuture的ExecutionException并传递给调用者。	
               此外，可以通过扩展线程池或者覆盖ThreadPoolExecutor的afterExecute(Runnable r, Throwable t)方法来自定义异常处理逻辑，
               此方法会在任务执行后无论成功与否都会被调用。
           `,
     },
     { 
          title: "多线程并发 --- 15、 问题：为何不建议在高并发场景下使用 newFixedThreadPool 搭配无界队列？",
          content: ` 
          	在高并发场景下，如果使用Executors.newFixedThreadPool并配置一个无界队列（如LinkedBlockingQueue），由于无界队列的特性，
               它会无限制地存储提交的任务，而固定线程数无法继续增长。	
               这样，在任务提交速度远大于线程处理速度的情况下，会导致任务不断堆积，进而可能耗尽系统内存，引发OOM。
               因此，通常建议在这种情况下考虑设置有界队列，或者使用能自动伸缩线程数量的线程池。
           `,
     },
     { 
          title: "多线程并发 --- 16、 问题：解释一下ThreadPoolExecutor中的“饱和策略”是什么意思？",
          content: ` 
           	“饱和策略”是指当线程池无法再接受新任务的情况下的处理机制。 	当线程池中所有的核心线程都在工作，且工作队列也已满，此时若继续提交任务，则线程池进入饱和状态。 	
               线程池通过拒绝策略来应对饱和情况，可以选择丢弃任务、让提交任务的线程自己执行任务、抛出异常等不同的处理方式。
           `,
     },
     { 
          title: "多线程并发 --- 17、 问题：什么是线程同步？为什么需要线程同步？",
          content: ` 
          	线程同步是一种机制，它确保了在多线程环境下，当多个线程访问同一块资源时，同一时间只能有一个线程访问资源或者某个临界区的代码块。	
               线程同步是为了避免多个线程同时访问和修改共享资源时产生的数据不一致和竞态条件，从而保持数据的一致性和完整性。
           `,
     },
     { 
          title: "多线程并发 --- 18、 问题：Java中有哪些常见的线程同步机制？",
          content: ` 
          Java中常见的线程同步机制包括：
          1、synchronized关键字：可以修饰方法或代码块，保证同一时刻只有一个线程访问被synchronized保护的代码区域。
          2、ReentrantLock：一个可重入的互斥锁定机制，相比synchronized提供了更多灵活性，如公平锁、非公平锁，以及tryLock、lockInterruptibly等方法。
          3、volatile关键字：确保了多线程环境下的共享变量可见性，但并不能替代互斥锁来保证原子性。
          4、Semaphore（信号量）：用于控制同时访问特定资源的线程数量。
          5、Condition：与Lock配套使用，提供更为灵活的线程间协调机制，允许线程在满足某种条件时才继续执行。
          6、CountDownLatch：一个同步辅助类，允许一个或多个线程等待其他线程完成操作后再执行。
          7、CyclicBarrier：让一组线程等待至某个屏障点，所有线程都到达后才能继续执行。
          8、Exchanger：允许两个线程之间交换数据。
           `,
     },
     { 
          title: "多线程并发 --- 19、 问题：什么是死锁？如何预防死锁？",
          content: ` 
          	死锁是指两个或更多的线程互相等待对方持有的锁资源，形成循环等待，导致所有线程都无法继续执行的情况。

               预防死锁的策略包括：
               1、避免嵌套加锁，尽量按固定的顺序获取锁。
               2、使用超时机制，防止无限期等待锁。
               3、设定锁的层次结构，遵循避免环路的原则。
               4、使用可中断锁，并适时检测和处理中断信号。
               5、尽可能减少锁持有时间，尽早释放锁资源。
           `,
     },
     { 
          title: "多线程并发 --- 20、 问题：什么是线程局部变量（ThreadLocal）？它的应用场景是什么？",
          content: ` 
          	线程局部变量(ThreadLocal)是一个可以为每个线程维持其自身的独立变量副本的类。每个线程都拥有自己的ThreadLocal变量副本，互不影响。

               应用场景包括：
               1、在多线程环境下为每个线程提供独立的变量副本，避免线程间共享和同步的问题。
               2、为每个线程提供线程特有的上下文信息，例如数据库连接、用户会话信息等。
           `,
     },
     { 
          title: "多线程并发 --- 21、 问题：解释一下Java内存模型中的“可见性”、“原子性”和“有序性”。",
          content: ` 
          1、可见性：当一个线程修改了共享变量的值后，其他线程能够立即得知这个修改。为了确保可见性，可以使用synchronized、volatile关键字或者final字段。
          2、原子性：一个操作（或一系列操作）要么全部完成，要么全部不完成，不会出现在执行过程中被其他线程干扰的情况。为了保证原子性，可以使用锁或者其他原子操作类如AtomicInteger等。
          3、有序性：程序执行的顺序按照代码的编写顺序进行。Java内存模型允许编译器和处理器对指令进行重排序，但在多线程环境下可能导致意料之外的行为。happens-before原则和内存栅栏（Memory Barrier）可以用来保障有序性。
           `,
     },
     { 
          title: "多线程并发 --- 22、 问题：什么是Java中的synchronized关键字？",
          content: ` 
          	synchronized是Java中用于实现线程同步的关键字，它可以确保任何时刻只有一个线程访问特定的代码块或方法。
               通过synchronized修饰的方法或者代码块，同一时间只能有一个线程执行，以此来保证数据的完整性，防止多线程环境下并发访问共享资源时可能出现的数据不一致或竞态条件。
           `,
     },
     { 
          title: "多线程并发 --- 23、 问题：什么是Java中的ReentrantLock？",
          content: ` 
          	ReentrantLock是Java并发包java.util.concurrent.locks中提供的一个可重入的互斥锁，它提供了与synchronized关键字类似的线程同步功能，
               但更强大且更灵活。ReentrantLock允许获取锁的线程再次进入，也支持公平锁和非公平锁两种模式，同时还提供了诸如等待可中断、超时获取锁等功能。
           `,
     },
     { 
          title: "多线程并发 --- 24、 问题：synchronized和ReentrantLock有什么区别？",
          content: ` 
          1、synchronized是Java的内置关键字，使用起来相对简单，无需手动管理锁的释放，而ReentrantLock是一个API级别的锁，需要显示调用lock()和unlock()方法来获取和释放锁。
          2、ReentrantLock提供了公平锁和非公平锁的选择，而synchronized是非公平锁。
          3、ReentrantLock提供了tryLock()、lockInterruptibly()等高级功能，可以更好地控制线程的中断和超时。
          4、ReentrantLock在通过Condition进行线程间协作时更加灵活。
           `,
     },
     { 
          title: "多线程并发 --- 25、 问题：Semaphore（信号量）",
          content: ` 
          	Semaphore是一种用于控制同时访问特定资源的线程数量的工具类。	通过它可以设定一个许可证的数量，每当线程调用acquire()方法时就会获取一个许可证，
               如果没有可用的许可证，线程将被阻塞直到其他线程释放许可证。线程在完成资源访问后调用release()方法释放许可证。	

               Semaphore的应用场景是什么？ 	
               Semaphore常用于限制数据库连接数、并发打印任务数、窗口服务客户数等场景，确保在任何时候，都不会超过预定的并发执行数。
           `,
     },
     { 
          title: "多线程并发 --- 26、 问题：什么是线程间的通信机制？",
          content: ` 
          	线程间的通信机制是指在多线程环境下，线程之间通过某种方式传递信息、协调执行或同步状态，确保线程之间能正确、有效地共享资源和执行任务。
           `,
     },
     { 
          title: "多线程并发 --- 27、 问题：Java中有哪些常见的线程间通信机制？",
          content: ` 
          1、wait()、notify()、notifyAll()：	这些方法基于Object类，配合synchronized关键字使用，实现线程间的唤醒和等待。
          wait()会使当前线程等待，
          notify()或notifyAll()可以唤醒一个或所有等待的线程。

          2、管程（Monitors）：	通过synchronized关键字隐式实现，它包括了对象监视器，允许线程获取和释放锁以及进行等待/通知操作。
          3、条件变量（Condition Objects）：	Java并发包中的java.util.concurrent.locks.Condition接口提供了比wait()/notify()更灵活的条件等待机制，
          它与ReentrantLock等锁类一起使用，每个锁可以有多个条件变量，每个条件变量代表一种线程等待和唤醒的条件。
          4、阻塞队列（Blocking Queue）：	Java并发包中的阻塞队列如ArrayBlockingQueue、LinkedBlockingQueue等，可以实现生产者-消费者模式的线程间通信，当队列满或空时，线程会自动阻塞等待或被唤醒继续执行。
          5、显式锁（Explicit Locks）：	如java.util.concurrent.locks.ReentrantLock等，除了提供互斥锁的功能，还支持获取锁的可中断性、尝试获取锁的超时时间等，以及与Condition接口联合使用的条件等待机制。
          6、信号量（Semaphore）：	用于控制同时访问特定资源的线程数量，线程在获取不到许可时会被阻塞，直到其他线程释放许可。
          7、Future与Callable：	Future接口表示异步计算的结果，可用于线程间的通信和结果的获取。Callable接口定义了call()方法，返回一个结果，可以用FutureTask包装Callable对象并提交给线程池执行。
           `,
     },
     { 
          title: "多线程并发 --- 29、 问题：什么是Java线程的中断机制？",
          content: ` 
          	Java线程的中断机制是一种协作式的线程停止方法。通过调用Thread.interrupt()方法，一个线程可以向另一个线程发送中断请求，被中断的线程并不会立即停止执行，而是会设置其内部的中断标志为true。
               线程在合适的时机检查中断状态，并根据业务逻辑决定如何响应中断请求。
           `,
     },
     { 
          title: "多线程并发 --- 30、 问题：请说明Phaser类在Java并发中的作用。",
          content: ` 
          	Phaser是Java 7引入的更为灵活的并发同步工具类，它可以用于多线程间的相互通信和同步。	
               Phaser允许注册参与阶段的线程，并在所有参与者都到达阶段时进行同步，它支持灵活的注册、未到达阶段的线程取消、阶段重用等特性。
               Phaser可以看作是CountDownLatch和CyclicBarrier的加强版，更加适应复杂的并发场景。
           `,
     },
     { 
          title: "多线程并发 --- 31、 问题：什么是线程安全？",
          content: ` 
             线程安全是指一个类或者程序在多线程环境下被多个线程同时访问时，依然能够表现出正确的行为，不会出现数据不一致、竞态条件或死锁等问题。
             换句话说，即使在并发执行的情况下，也能保证对象状态的完整性。
           `,
     },
     { 
          title: "多线程并发 --- 33、 问题：如何确保线程安全？",
          content: ` 
             1、同步机制：使用synchronized关键字同步代码块或方法，确保同一时间只有一个线程访问共享资源。   
             2、原子类：Java并发包java.util.concurrent.atomic中提供了原子操作类，如AtomicInteger等，它们的更新操作是原子性的。  
             3、线程安全的数据结构：使用线程安全的集合类，如ConcurrentHashMap、CopyOnWriteArrayList等。   
             4、锁机制：如ReentrantLock等，提供了比synchronized更强大的功能，如可中断锁、公平锁等。
           `,
     },
     { 
          title: "多线程并发 --- 34、 问题：列举一些Java中线程安全的类。",
          content: ` 
             Vector（ 推荐使用CopyOnWriteArrayList代替）   
             Collections.synchronizedList/Set/Map返回的包装类   
             java.util.concurrent包下的并发容器类，如ConcurrentHashMap、CopyOnWriteArrayList等   
             Atomic系列的原子类，如AtomicInteger、AtomicLong、AtomicReference等
           `,
     },
     { 
          title: "多线程并发 --- 35、 问题：线程安全问题有哪些？",
          content: ` 
             竞态条件（Race Condition）：多个线程访问共享资源时，由于执行顺序不确定导致结果不一致。   
             死锁（Deadlock）：两个或多个线程相互等待对方释放资源，导致所有线程都无法继续执行。   
             活锁（Livelock）：线程间互相等待，虽然都在执行却没有进展，就像陷入僵局。   
             资源饥饿（Resource Starvation）：某个线程始终得不到必要的资源，无法继续执行。
           `,
     },
];
