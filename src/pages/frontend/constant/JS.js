export default [
  {
    title: "JS --- 1.基本数据类型",
    content: `
    JavaScript 共有八种数据类型，分别是
    Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。
    其中 Symbol 和 BigInt 是 ES6 中新增的数据类型
  `,
  },
  {
    title: "JS --- 2.let、const、var的区别",
    content: `
    1. let和const有暂时性死区，var没有
    2. let和const声明的变量具有块级作用域，var没有
    3. let和const不可以重复声明，var可以
    4. const赋值后不可以重新赋值，let和var可以重新赋值
    5. const必须有初始值、let和var不需要
  `,
  },

  {
    title: "JS --- 3.数据类型检测的方式有",
    content: `
    1. typeof   除了null 的基本数据类型都能正确判断，复杂数据类型判断为object 
    2.  instanceof   可以正确判断对象的类型，原理是判断在其原型链中能否找到该类型的原型。 
    3.  constructor   原理是通过构造函数来进行判断
    4.  Object.prototype.toString.call   可以判断所有数据类型
  `,
  },

  {
    title: "JS --- 4.null 和 undefined 区别 ",
    content: `
    undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。 
  `,
  },

  {
    title: "JS --- 5.判断一个对象为空对象的方式",
    content: `
    1.JSON.stringfy({})==='{}' （转化为字符串对比）
    2.Object.keys({}).length===0（获取对象的key数组的长度为0）
    3.Object.values({}).length===0 （获取对象的value数组的长度为0）
    4.Object.hasOwnProptyName({}).length===0（获取自身属性数组长度为0）
    5.使用for in循环遍历，在遍历里返回false，外部返回true
  `,
  },
  {
    title: "JS --- 6.箭头函数和普通函数的区别",
    content: `
    1.箭头函数没有自己的this
    2.箭头函数不能使用关键字new，会报错
    3.箭头函数不能作为构造函数
    4.箭头函数没有prototype（原型）
    5.箭头函数没有arguments（参数列表）
    6.箭头函数不能作为生成器函数
    `,
  },
  {
    title: "JS --- 7.this指向",
    content: `
    1.this指向函数的直接调用者（而非间接调用者，也就是.前面的）
    2.如果有new关键字，this指向new出来的那个对象
    3.在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。
    `,
  },
  {
    title: "JS --- 8.跨域",
    content: `
    跨域就是，从网页去请求另一个域名的资源时，如果有域名、端口、协议其中一个不同，都会导致浏览器跨域。这是浏览器的一种保护机制。
    常用解决方案：
    - 跨域资源共享（CORS）
    - nginx代理跨域 
    - nodejs中间件代理跨域
    - jsonp跨域
    - postMessage
    产生跨域的原因：(照着读就行)
      因为浏览器有一个安全机制叫同源策略。同源就是指协议、域名、端口都一样，如果任意一项不一致就会出现跨域。简单点说就是，你的网页URL和你调用的接口URL不是一个地方的，浏览器觉得有安全风险，不想让你使用这个接口的数据。
    解决方法：常用的有3种
      1、用的最多的就是服务器代理（proxy）
      代理服务器是一种通过在同一个域名下设置一个代理服务器，将需要跨域访问的请求先发送到代理服务器上，再由代理服务器向目标服务器发出请求，并将请求结果返回给客户端的技术。
      这样客户端就可以避免直接访问跨域服务器，从而可以绕开浏览器的同源策略。你像vue项目根目录下找到vue.config.js文件，配置proxy对象，react的话可以直接在package.json配置文件中配置
      2.然后是CORS，它就是一种通过服务器设置响应头信息，允许指定域名的请求跨域访问资源，实现的跨域资源共享。具体就是，在服务端设置 Access-Control-Allow-Origin(俄塞斯康戳俄拉奥俄瑞真) 响应头字段来指定允许的来源域名，以及其他相关的响应头信息。这个需要后端配置相应的响应头信息，而且老版本浏览器不支持比如 IE8 IE9
      3.再就是JSONP它通过动态创建<script>标签来获取跨域资源，利用回调函数把数据传递回来。
      浏览器把请求资源的URL当<script>标签的src属性值，然后把这个<script>标签插入到文档中。因为<script>标签的加载行为是通过GET请求实现的，因此JSONP只能发送GET请求。
    `,
  },
  {
    title: "JS --- 9.cookie和storage的区别",
    content: `
    1.存储大小不同，cookie空间只有4k，localStorage和SeesionStorage有5M
    2.cookie会自动携带在请求中，localStorage和SeesionStorage不会
    3.生命周期不同，cookie可以设置生命周期，localstorage生命周期是永久，sessionstorage生命周期是会话级别，浏览器关闭就销毁
    4.作用域不同，cookie前后端都可以修改，storage只用于前端
    `,
  },
  {
    title: "JS --- 10.get和post的区别",
    content: `
    1.请求方式不同，一种语意是获取，一种是提交，通常在请求数据时用get，修改数据时用post
    2.参数位置不同，get 是在拼接在url后面，post是在请求体body里
    3.参数类型不同，get只能携带查询字符串，post可以携带json、formdata格式还有其他格式
    4.get参数长度有限制，post无限制
    4.get是明文传递参数，post是密文，get不安全
    5.get会被浏览器主动缓存，post不会
    `,
  },
  {
    title: "JS --- 11.事件轮询",
    content: ` 
    JavaScript 是单线程的，同一时间只能做一件事。所有任务都需要排队，前一个任务结束，才会执行后一个任务，为了保证任务有序的执行，事件轮询就是单线程任务调度的一种方式，单线程任务分为同步任务和异步任务，而异步任务又分为宏任务和微任务
    过程： 浏览器会首先执行宏任务， 如果执行过程中，遇到宏任务，就把他加入宏任务队列，遇到微任务，就把他加入微任务队列，当前宏任务执行完后，会判断 微任务列表 中是否有任务，如果有，执行微任务，当所有微任务执行完后，再执行下一个宏任务，不断循环。
    宏任务：主代码块、setTimeOut、setInterval、script、I/O操作、UI渲染
    微任务：promise、async/await(返回的也是一个promise)、process.nextTick
   `,
  },
  {
    title: "JS --- 12.Hash和history的区别",
    content: `
    hash与history一般指前端框架中的路由模式，对应两种路由 hash路由和history路由，区别如下:
    1. 浏览器url中hash 路由带了一个很丑的 #，而history是没有的
    2. hash即浏览器地址栏 URL 中的 # 符号，hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，因此改变 hash 不会重新加载页面
    3. history利用了 HTML5新增的 pushState() 和 replaceState() 方法，在已有 back()、forward()、go() 的基础上，提供了对历史记录进行修改的功能。调用pushState() 和 replaceState()时，虽然改变了当前的 URL，但浏览器不会向后端发送请求，但如何用户刷新页面，会导致浏览器向服务器发起请求，如后端没有做出适当的响应，则会显示404页面
    4. hash路由兼容性比histroy路由好
    `,
  },
  {
    title: "JS --- 13.强缓存和协商缓存",
    content: `
    浏览器缓存主要分为强缓存（也称本地缓存）和协商缓存（也称弱缓存）。浏览器在第一次请求发生后，再次发送请求时
    强缓存：浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的Cache-Control和Expires来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。
    协商缓存:协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。主要看响应头的Etag和last-modify这两个字段.
    强缓存状态码200，协商缓存304.
   `,
  },
  {
    title: "JS --- 14.url过程",
    content: `
    1. URL解析：当在浏览器地址栏输入URL后，浏览器会判断这个URL的合法性，以及是否有可用缓存。如果判断是URL则进行域名解析，如果不是URL，则直接使用搜索引擎搜索。
    2. 域名解析：浏览器首先会解析域名，获取对应的IP地址。这个过程涉及到了域名解析服务器的查询和转发，如果本地DNS缓存中有对应的条目，则可以直接使用缓存的IP地址。
    3. TCP连接：获取到IP地址后，浏览器便会与服务器建立TCP连接，包括客户端向服务器发送SYN(同步)报文，服务器回复SYN+ACK(同步/应答)报文，最后客户端再回复ACK(应答)报文，完成三次握手过程。
    4. 发送HTTP请求：TCP连接建立后，浏览器便会向服务器发送HTTP请求报文，其中包括请求方法、路径、协议版本等信息，以及请求头部信息等。
    5. 服务器响应：服务器接收到请求后，会从服务器文件系统或者处理逻辑中获取到数据，生成HTTP响应报文，并将其返回给浏览器。
    6. 浏览器渲染：当浏览器接收到响应报文后，会对HTML文档进行解析，并构建dom树、css树、渲染树等，最终将页面呈现给用户。
    7. 连接关闭：当浏览器从服务器接收到所有需要的数据后，就会关闭TCP连接。
    `,
  },
  {
    title: "JS --- 15.浏览器渲染过程",
    content: `
    1. 解析html，浏览器首先解析HTML文档，将其转化为dom树。这个过程中，浏览器会将HTML标签转化为节点，形成DOM树的结构。
    2. 解析CSS。浏览器解析CSS文件，构建css树。CSS树是包含所有CSS样式信息的树结构。
    3. 构建渲染树。将DOM树和CSSOM树合并，形成渲染树。渲染树只包含那些需要显示在页面上的元素，并且每个元素根据CSSOM包含了相应的样式信息。
    4. 布局计算。根据渲染树的结构，计算每个节点在屏幕上的大小、位置等属性，生成布局信息。这个过程涉及到元素的尺寸和位置的计算，可能会发生回流和重绘。
    5. 页面绘制。将生成的布局信息交给浏览器的绘图引擎，通过GPU加速将像素绘制到屏幕上。这一步将布局信息转化为实际的视觉展示。
    6. 执行JavaScript代码。浏览器的主线程负责解析和执行JavaScript代码。如果JavaScript代码修改了DOM，这可能会影响渲染树的构建和页面的绘制。
    `,
  },
  {
    title: "JS --- 16.script脚本的异步加载顺序",
    content: `
    script有两种异步加载方式  分别是defer与async
    defer与async的区别是：
    defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；
    async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。
    另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。
    `,
  },
  {
    title: "JS --- 17.ES6模块化和commonjs模块化区别",
    content: `
    1.语法不同（ES Module使用import导入，export或者export default导出
      CommonJS使用require导入，exports导出）
    2.加载时机不同
      ES Module是编译时加载，代码执行前，静态分析阶段，使用import函数时是运行时加载
      CommonJS是运行时加载，必须等模块内所有代码运行结束后才能导出
    3.加载方式不同
      ES Module是异步加载，不会阻塞代码
      CommonJS是同步加载，如果加载的模块够大时，可能会阻塞后续代码
    4.导出方式不同
      ES Module是导出值的引用，多个文件引入同一个模块得到的引用是同一个
      CommonJS是值的拷贝
    5.效率不同
      ES Module加载效率更高，编译时加载、模块缓存机制、并行加载、tree-shaking
      CommonJS效率相对较低
    6.导出的内容不同
      ES Module是编译阶段静态分析，导出静态定义，所以很多ES Module模块化的优化都是在这	个阶段做的，这也就是ES Module能够更好的支持tree shaking的原因
      CommonJS导出的是对象，必须加载完模块内的所有代码才能生成导出对象，导致commonjs	不好优化
    7.ES Module导出的变量是只读的不能修改，修改了会报错，CommonJS导出的变量是可以修改的，这是因为ES Module导出的是引用，如果可修改会影响其他模块的导入，commonjs导出的是值的拷贝，不会影响
  `,
  },

  {
    title: "JS --- 18.es6新特性",
    content: `
    1.class 类
    2.let、const变量声明方式
    3.新增了promise异步
    4.新增了symbol基本数据类型
    5.新增了proxy （代理）Api
    6.新增了set、map数据结构
    7.es6模块化
    8.新增了箭头函数
    9.新增了模板字符串
    10.新增了...扩展运算符
    11.新增了生成器函数
    12.for...of循环
     `,
  },
  {
    title: "JS --- 19.forin 和 forof 的区别",
    content: `
    遍历对象时：for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名； 
    遍历数组时：for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值 
    总的来说for...in适合遍历对象，for...of适合遍历数组等可迭代的数据类型（数组、字符串等）
    `,
  },
  {
    title: "JS --- 20.原型和原型链",
    content: `
    原型 就是构造函数的prototype属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。
    原型链 就是当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，这种链状结构就叫做原型链
    `,
  },
  {
    title: "JS --- 21.继承方式",
    content: `
    （1）原型链的方式来实现继承，缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。 
    （2）借用构造函数的，原理：在子类型的函数中调用超类型的构造函数来实现的，问题就是无法实现函数方法的复用。 
    （3）组合继承，通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。
    （4）原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。
    （5）寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。
    （6）寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。
    `,
  },
  {
    title: "JS --- 21.事件代理和事件委托",
    content: `
    事件代理 也就是 事件委托，不是直接给标签添加事件 是给标签的父级添加事件 通过 事件对象 判断触发事件的标签对象是谁 执行不同的函数程序的语法形式
    委托的优点： 减少内存消耗、动态绑定事件
    `,
  },
  {
    title: "JS --- 22.面向对象与面向过程的区别",
    content: `
    面向过程就是拆解出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；
    面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
    `,
  },
  {
    title: "JS --- 23.作用域、作用域链",
    content: `
    js作用域有两种
    （1）全局作用域 
    最外层函数和最外层函数外面定义的变量拥有全局作用域所有未定义直接赋值的变量自动声明为全局作用域
    （2）函数作用域 函数作用域声明在函数内部的变量，一般只有固定的代码片段可以访问到 作用域是分层的，内层作用域可以访问外层作用域，反之不行
    作用域链： 在当前作用域中查找所需变量，如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window 对象就被终止，这一层层的关系就是作用域链。
    `,
  },

  {
    title: "JS --- 24.垃圾回收机制",
    content: `
    垃圾回收是动态存储管理技术，会自动地释放"垃圾"(不再被程序引用的对象)，按照特定的垃圾收集算法来实现资源自动回收的功能。
    工作流程：
      1.垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。
      2.去掉环境中的变量以及被环境中的变量引用的变量的标记。
      3.再被加上标记的会被视为准备删除的变量。
      4.垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。
      常用的两种方法：
      1.标记清除（make-and-sweep）
      当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“
      垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉
      在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了
      2.引用计数 垃圾回收器会按照固定的时间间隔周期性的执行。
      就是语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放
      如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏
    `,
  },
  {
    title: "JS --- 25.节流和防抖",
    content: `
    节流：节流是指当一个事件触发的时候,为防止事件的连续频繁触发,设置定时器,达到一种一段事件内只触发一次的效果,在当前事件内不会再次触发,当前事件结束以后,再次触发才有效.
    防抖：防抖是指当一个事件触发的时候, 为防止频繁触发事件, 设置定时器,以达到一种 频繁触发期间不处理, 只有当最后一次连续触发结束以后才处理
    `,
  },
  {
    title: "JS --- 26.Promise",
    content: `
    Promise 是es6新增的一种异步编程的解决方案：promise是一个对象，承诺它过一段时间会给你一个结果，promise有三种状态： pending(等待态)，fulfiled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。
    promise是用来解决两个问题的：
    回调地狱，代码难以维护
    `,
  },
  {
    title: "JS --- 27.Promsie 和 async await 的区别",
    content: ` 
    区别：
    Promise 允许链式调用和异步处理错误，但可能导致代码的可读性较差。
    async/await 提供了更简洁的语法，看起来像同步代码，同时提供了同步地处理错误的能力，增强了代码的可读性。
    两者都是非阻塞的，但 async/await 提供了更好的错误处理和可读性
    `,
  },
  {
    title: "JS --- 28.promise常用api",
    content: `
    Promise.resolve(value) : 类方法，该方法返回一个以 value 值解析后的 Promise 对象 
    Promise.reject : 类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。
    Promise.prototype.then : 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一 个新的 Promise 对象，才可以让之后的 then 回调接收。
    Promise.prototype.catch : 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。
    Promise.race ：类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。
    Promise.all : 类方法，多个 Promise 任务同时执行，如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返 回 rejected 任务的结果。 
    `,
  },
  {
    title: "JS --- 29.设计模式",
    content: `
    * 发布订阅模式:
      这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。
    * 中介者模式 :
      观察者模式通过维护一堆列表来管理对象间的多对多关系，中介者模式通过统一接口来维护一对多关系，且通信者之间不需要知道彼此之间的关系，只需要约定好API即可。
    * 代理模式 :
      为其他对象提供一种代理以控制对这个对象的访问。
      代理模式使得代理对象控制具体对象的引用。代理几乎可以是任何对象：文件，资源，内存中的对象，或者是一些难以复制的东西。
    * 单例模式 :
      保证一个类只有一个实例，并提供一个访问它的全局访问点（调用一个类，任何时候返回的都是同一个实例）。
    * 工厂模式 :
      工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一
      个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型
    * 装饰者模式 : 
      装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责（方法或属性）。与继承相比，装饰者是一种更轻便灵活的做法。
      `,
  },
  {
    title: "JS --- 30.new一个对象的过程",
    content: `
    * 1.开辟一个堆内存，创建一个空对象
    * 2.执行构造函数，对这个空对象进行构造
    * 3.给这个空对象添加__proto__属性
    `,
  },
  {
    title: "JS --- 31.http 和 https 的区别",
    content: `
    * 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    * 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    * 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    * 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
    `,
  },
  {
    title: "JS --- 32.http状态码",
    content: `
    1xx 信息，表示临时响应并需要请求者继续执行操作
    100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
    101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。
    102：由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。
    2XX 成功
    200 表示从客户端发来的请求在服务器端被正确处理 ✨
    201  请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴
    202  请求已接受，但是还没执⾏，不保证完成请求
    204 表示请求成功，但响应报⽂不含实体的主体部分
    206 进⾏范围请求 ✨
    3XX 重定向
    301 永久性重定向，表示资源已被分配了新的 URL
    302 临时性重定向，表示资源临时被分配了新的 URL ✨
    303 表示资源存在着另⼀个 URL，应使⽤ GET ⽅法丁⾹获取资源
    304 表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况
    307 临时重定向，和302含义相同
    4XX 客户端错误
    400 请求报⽂存在语法错误 ✨
    401 表示发送的请求需要有通过 HTTP 认证的认证信息 ✨
    403 表示对请求资源的访问被服务器拒绝 ✨
    404 表示在服务器上没有找到请求的资源 ✨
    408  客户端请求超时
    409 请求的资源可能引起冲突
    5XX 服务器错误
    500 表示服务器端在执⾏请求时发⽣了错误 ✨
    501 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务
    器不⽀持的某个⽅法
    503 表明服务器暂时处于超负载或正在停机维护，⽆法处理请求
    505 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本
`,
  },
  {
    title: "JS --- 33.懒加载和预加载",
    content: `
    * 懒加载：懒加载也叫延迟加载，延迟加载网络资源或符合某些条件时才加载资源。常见的就是图片延时加载。
      懒加载的意义：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。
      懒惰实现方式：
      * 1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.
      * 2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。
      * 3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。
    * 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。
      两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。预加载应用如广告弹窗等。
  `,
  },
  {
    title: "JS --- 34.less和sass的区别",
    content: `
    * 编译环境不一样，sass是服务器端处理的，可以用Ruby、node-sass来编译；less需要引入less.js来处理输出，也可以使用工具在服务器端处理成css，也有在线编译的。
    * 变量定义符不一样，less用的是@，而sass用$。
    * sass支持分支语句，less不支持
    * `,
  },
  {
    title: "JS --- 35.闭包",
    content: `
    闭包就是函数内部返回另一个函数，并且在外部有变量接收这个函数，就会形成闭包
    闭包的优点：
    1.保存变量不被销毁
    2.保护变量不被外部作用域访问
    闭包的缺点：
    1.产生的闭包内存不会被销毁，容易造成内存泄露
    `,
  },
  {
    title: "JS --- 36.http请求类型",
    content: `
    GET: 通常⽤于请求服务器发送某些资源
    HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致. 该请求⽅法的⼀个使⽤场景是在
    下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源
    OPTIONS: ⽤于获取⽬的资源所⽀持的通信选项
    POST: 发送数据给服务器
    PUT: ⽤于新增资源或者使⽤请求中的有效负载替换⽬标资源的表现形式
    DELETE: ⽤于删除指定的资源
    PATCH: ⽤于对资源进⾏部分修改
    CONNECT: HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器
    TRACE: 回显服务器收到的请求，主要⽤于测试或诊断
    `,
  },
  {
    title: "JS --- 37.==和===的区别",
    content: `
    “==”：不全相等，只⽐较数据，不⽐较类型，如果两边的类型不⼀致，则会
    进⾏强制类型转化后再进⾏⽐较
    “===”：全等，既要⽐较数据，也⽐较数据类型，如果两边的类型不⼀致时，
    不会做强制类型准换，直接返回 false
    `,
  },
  {
    title: "JS --- 38.实现new操作符",
    content: `
    new操作符的执⾏过程：
    1、在函数内部创建⼀个新的空对象，
    2、将创建好的对象的__proto__指向该函数的prototype；
    3、执⾏构造函数中的代码，将其中的this指向当前新创建的对象，
    4、将该对象作为函数的返回值通过return将该对象返回
    `,
  },
  {
    title: "JS --- 39.事件冒泡和事件捕获",
    content: `
    事件冒泡（Event Bubbling）。事件从触发元素开始，逐级向上传播到DOM树的最顶层，通常是document对象。
    事件捕获（Event Capturing）。事件从DOM树的根节点开始，逐级向下传播到最具体的元素
    `,
  },
  {
    title: "JS --- 40.forEach和map⽅法有什么区别",
    content: `
    这⽅法都是⽤来遍历数组的，两者区别如下：
    forEach()⽅法会针对每⼀个元素执⾏提供的函数，对数据的操作会改变
    原数组，该⽅法没有返回值；
    map()⽅法不会改变原数组的值，返回⼀个新数组，新数组中的值为原数
    组调⽤函数处理之后的值；
    `,
  },
  {
    title: "JS --- 41.虚拟dom",
    content: `
    ⽤ JavaScript 对象结构表示 DOM 树的结构；然后⽤这个树构建⼀
    个真正的 DOM 树，插到⽂档当中 当状态变更的时候，重新构造⼀棵新
    的对象树。然后⽤新的树和旧的树进⾏⽐较，记录两棵树差异 把所记录
    的差异应⽤到所构建的真正的 DOM 树上，视图就更新了。Virtual DOM
    本质上就是在 JS 和 DOM 之间做了⼀个缓存
    `,
  },
  {
    title: "JS --- 41.call、apply、bind区别",
    content: `
    执行时机：call和apply会在调用时立即执行函数；bind返回的是一个改变了this指向的新函数，这个新函数只有在被调用时才会执行。
    参数传递方式：call方法接受一个参数列表，其中参数通过逗号分隔；
    apply方法接受一个数组或类数组对象作为参数，这些参数会在函数调用时被展开；
    bind方法也接受一个参数列表，并且可以多次传入参数。
    `,
  },
  {
    title: "JS --- 42.requestAnimationFrame",
    content: `
    requestAnimationFrame() ⽅法告诉浏览器您希望执⾏动画并请求浏
    览器在下⼀次重绘之前调⽤指定的函数来更新动画。该⽅法使⽤⼀
    个回调函数作为参数，这个回调函数会在浏览器重绘之前调⽤。
    `,
  },
  {
    title: "JS --- 43.js组成部分",
    content: `
    ECMAScript（语法部分）：JavaScript 语言基础
    DOM（文档对象模型）：规定了访问 HTML 和 XML 的方法
    BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法
    `,
  },
  {
    title: "JS --- 44.js事件流模型",
    content: `
    “事件冒泡”：事件逐级向上传播
    “事件捕捉”：事件逐级向下传播，一直到最具体的
    “DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡
    `,
  },
  {
    title: "JS --- 44.jsdom委托原理",
    content: `
    事件委托原理: 事件冒泡机制（把子元素的事件行为 委托给 父级元素执行优点）

    优点:
    1. 可以大量节省内存占用，减少事件注册
    2. 可以实现当新增子对象时，无需再对其进行事件绑定

    缺点:
    如果把所有事件都用事件代理，可能会出现事件误判
    `,
  },
  {
    title: "JS --- 45.js变量提升与块级作用域",
    content: `
    变量提升：就是会把变量定义提升到当前作用域的最上面,只有var定义的变量存在变量提升
    块级作用域：JS 中作用域有：全局作用域、函数作用域。没有块作用域的概念。ES6中新增了块级作用域。块作用域由 { } 包括，if 语句和 for 语句里面的{ }也属于块作用域。在外边不能调用块作用域里边定义的变量
    `,
  },
  {
    title: "JS --- 46.js prototype 和 proto 的关系是什么",
    content: `
    prototype: 所有函数都会有一个prototype属性, 它就是函数的原型对象
    proto: 所有实例对象上都会有一个proto属性, 它等同于函数的原型对象
    `,
  },
  {
    title: "JS --- 47.js原型链详细",
    content: `
    所有的对象都拥有proto属性，它指向对象构造函数的 prototype 属性
    所有的函数都同时拥有proto和 prototype 属性
    函数的proto指向自己的函数实现 函数的 protytpe 是一个对象(原型)
    所以函数的 prototype 也有proto属性 指向 Object.prototype
    Object.prototype.proto指向 null
    `,
  },
  {
    title: "JS --- 48.js数组方法",
    content: `
    1）Array.push()：此方法是在数组的后面添加新加元素，此方法改变了数组的长度：
    2）Array.pop()：此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度：
    3） Array.shift()：此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度：
    4） Array.unshift()：此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：
    5）Array.isArray()：判断一个对象是不是数组，返回的是布尔值
    6） Array.concat()：此方法是一个可以将多个数组拼接成一个数组：
    7）Array.toString() ： 把数组作为字符串返回
    8） Array.join()       ：以指定字符拼接成字符串，然后返回
    9） Array.splice：(开始位置， 删除的个数，元素)
    10）Array.map()：此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组
    11）Array.forEach()：此方法是将数组中的每个元素执行传进提供的函数，没有返回值，直接改变原数组，注意和 map 方法区分
    12）Array.filter()：此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回
    13）Array.every()：此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回 true，否则为 false：
    14）Array.some()：此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回 true，若所有元素都不满足判断条件，则返回 false：
    15）Array.reduce()：此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型：
    `,
  },
  {
    title: "JS --- 49.js字符串方法",
    content: `
    trim(): 去首尾空格
    split(sep，limit)：将字符串分割为字符数组，limit 为从头开始执行分割的最大数量
    indexOf(str):返回 str 在父串中第一次出现的位置，若没有则返回-1
    lastIndexOf(str):返回 str 在父串中最后一次出现的位置，若没有则返回-1
    substr(start，length)：从字符索引 start 的位置开始，返回长度为 length 的子串
    substring(from,to)：返回字符索引在 from 和 to（不含）之间的子串
    slice(start,end)：返回字符索引在 start 和 end（不含）之间的子串
    toLowerCase()：将字符串转换为小写
    toUpperCase()：将字符串转换为大写
    replace(str1,str2):str1 也可以为正则表达式，用 str2 替换 str1
    concat(str1,str2,...):连接多个字符串，返回连接后的字符串的副本
    match(regex):搜索字符串，并返回正则表达式的所有匹配
    charAt(index):返回指定索引处的字符串
    charCodeAt(index):返回指定索引处的字符的 Unicode 的值
    fromCharCode():将 Unicode 值转换成实际的字符串
    search(regex):基于正则表达式搜索字符串，并返回第一个匹配的位置
    valueOf()：返回原始字符串值
    `,
  },
  {
    title: "JS --- 50.js new操作符具体做了什么？",
    content: `
    在内存创建一个新对象
    把构造函数中this指向新建的对象
    会在新对象上添加一个__proto__属性,指向函数的原型对象prototype
    判断函数返回值,如果值是引用类型就直接返回值；否则返回this(创建的新对象)
    `,
  },
  {
    title: "JS --- 51.js 深浅拷贝区别",
    content: `
    浅拷贝的话，如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址。就是浅拷贝是拷贝一层，深层次的引用类型就是共享内存地址。
    深拷贝除了拷贝基本类型的值，还完全复刻了对象类型。就是开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。
  
    浅拷贝方法：Object.assign、Array.prototype.slice(), Array.prototype.concat()和 拓展运算符实现的复制
    深拷贝方法：最常用的就是JSON.stringify()，还有就是JQuery的jQuery.extend()，再就是lodash的_.cloneDeep()，或者手写循环递归了
    `,
  },
  {
    title: "JS --- 52.js同步异步区别",
    content: `
    同步: 下面代码会等待上面 同步代码执行完毕
    异步: 下面代码不会等待上面异步代码执行完毕
    同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，
    新内容出现，用户看到新内容,进行下一步操作
    异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。
    等请求完，页面不刷新，新内容也会出现，用户看到新内容
    `,
  },
  {
    title: "JS --- 53.js为什么 JS 是单线程,  而不是多线程",
    content: `
    单线程是指 JavaScript 在执行的时候，有且只有一个主线程来处理所有的任务。
    目的是为了实现与浏览器交互。
    我们设想一下，如果 JavaScript 是多线程的，现在我们在浏览器中同时操作一个
    DOM，一个线程要求浏览器在这个 DOM 中添加节点，
    而另一个线程却要求浏览器删掉这个 DOM 节点，
    那这个时候浏览器就会很郁闷，他不知道应该以哪个线程为准。
    所以为了避免此类现象的发生，降低复杂度，JavaScript
    选择只用一个主线程来执行代码，以此来保证程序执行的一致性。
    `,
  },
  {
    title: "JS --- 54.js严格模式的使用与作用",
    content: `
    答案：在代码前面使用"use strict"就可以开启严格模式;

    作用：
    消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;
    消除代码运行的一些不安全之处，保证代码运行的安全；
    提高编译器效率，增加运行速度；
    为未来新版本的 Javascript 做好铺垫。

    特点
    变量必须要通过修饰符进行声明
    函数的参数不能有同名属性，否则报错
    禁止 this 指向全局对象
    增加了保留字（比如 protected 、 static 和 interface ）
    不能删除变量 delete prop
    `,
  },
  {
    title: "JS --- 55.js线程与进程的区别",
    content: `
    一个程序至少有一个进程, 一个进程至少有一个线程。
    线程的划分尺度小于进程，使得多线程程序的并发性高。
    另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
    线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，
    由应用程序提供多个线程执行控制。
    从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
    `,
  },
  {
    title: "JS --- 56.Promise.all() 原理",
    content: `
    Promise.all() 是一个内置的辅助函数，它接收一个包含多个 Promise 的可迭代对象作为参数，并返回一个新的 Promise。这个新的 Promise 在传入的所有 Promise 都成功解决时才会成功解决，并将所有 Promise 的解决值按顺序组成的数组作为结果；如果任何一个 Promise 被拒绝，则返回的 Promise 会立即被拒绝，并传递第一个被拒绝 Promise 的拒绝原因。
    `,
  },
  {
    title: "JS --- 57.Promise.all()实现根据传入url顺序, 返回按序结果",
    content: `
    用参数数组下标用来保证按序存储，循环的时候用变量记录和保证获取到了想要的所有数据，就比如说定义一个count循环的时候count++，起一个计数的作用，确保所有传入的 Promise 都被成功处理后，才会触发 resolve(res)，解决返回的 Promise。这样可以保证返回的 Promise 在所有传入的 Promise 都完成后才会被解决，返回结果数组中的顺序也与传入的 Promise 数组保持一致。
    `,
  },
  {
    title: "JS --- 58. promise的链式调用",
    content: `
    链式调用的话就是说 then 的函数和新 promise 的 resolve 一起 push 到前一个 promise 的 callbacks 数组中，就是当前一个 promise 完成后，调用它的 resolve 变更状态，在这个 resolve 里会依次调用 callbacks 里的回调，这样就执行了 then 里的方法了，然后等 then 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 promise 的 resolve，让其状态变更，这又会依次调用新 promise 的 callbacks 数组里的方法，循环往复。。如果返回的结果是个 promise，则需要等它完成之后再触发新 promise 的 resolve，所以可以在其结果的 then 里调用新 promise 的 resolve，基本就是这么一个过程吧。
    `,
  },
  {
    title: "JS --- 59. 三次握手",
    content: `
    第一次握手（SYN）
    客户端发送SYN包：
    客户端发送一个 SYN 包到服务端。这个 SYN 包的 Seq=0，表明客户端希望与服务端建立连接，并且告知服务端的起始序列号为0。

    第二次握手（SYN-ACK）
    服务器回应SYN-ACK包：
    服务器确认客户端的SYN请求，发送SYN和ACK，Ack=1， 说明服务器已经收到客户端 Seq=0 的字节，期望下次收到服务端 Seq=1 的字节，Seq = 0，告知客户端的起始序列号也为0。

    第三次握手（ACK）
    客户端发送ACK包：
    客户端收到服务器的SYN-ACK包后，会发送一个ACK包。这个包的ACK=1，说明客户端已经收到服务端 Seq=0 的包，期望收到 Seq=1 的包
    `,
  },
  {
    title: "JS --- 60. 四次挥手",
    content: `
    四次挥手过程：
    第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入fin_wait_1状态。
    第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。
    第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。
    第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。
    `,
  },
  {
    title: "JS --- 61. 事件循环",
    content: `
    JS 是一种单线程编程语言，这就是说它在同一时间只能执行一个任务，或者说，在任何给定的时间里，JS 引擎中只会有一个执行线程来处理JS脚本。这个执行线程遵循从上至下逐行执行代码的原则。事件循环呢，就是JS执行上下文中的一种机制，用来处理异步操作。它的核心思想是把所有的异步任务放入一个队列中，然后按照队列中的顺序依次执行，直到队列为空为止。主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。
    下面是执行顺序：
    1.先执行同步代码，所有同步代码都在主线程上执行，形成一个执行栈。
    2.当遇到异步任务时，会把它挂起并添加到任务队列中，宏任务放入宏任务队列，微任务放进微任务队列。
    3.当执行栈为空时，事件循环从任务队列中取出一个任务，加入到执行栈中执行。
    4.重复上述步骤，直到任务队列为空。
    概括以下就是 js是一门单线程语言，通过事件循环机制实现异步执行代码。
    `,
  },
  {
    title: "JS --- 62. 单线程的好处",
    content: `
    首先就是占用资源少，因为只有一个线程
    然后相比于多线程的话，它不用切换执行上下文，速度更快；
    然后对于访问DOM结构获取变量的时候不用考虑复杂的并发
    `,
  },
  {
    title: "JS --- 63. JSON.stringify实现深拷贝的缺点",
    content: `
    会忽略 undefined和Symbol
    不能序列化函数
    无法处理循环引用
    不支持RegExp(正则)和Map还有Set

    `,
  },
  {
    title: "JS --- 64. js数组去重方法",
    content: `
    利用 ES6 Set 去重（ES6 中最常用）
    利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）
    利用 indexOf 去重
    利用 sort()
    利用 includes()
    利用 hasOwnProperty
    利用 filter
    利用递归去重
    利用 Map 数据结构去重
    `,
  },
  {
    title: "JS --- 65. BigInt 的使用",
    content: `
    BigInt 是一种数值数据类型，用于表示旧数值数据类型 number 无法表示的小数和大数。每个 BigInt 值都必须在数字后包含小写字母 n。
    使用场景：
    财务计算：BigInt 在财务计算中很重要，因为可以处理非常大量的交易和货币转换
    密码学和安全计算：BigInt 在密码学中用于生成非常难以预测或破解的非常大的随机数
    游戏开发：在游戏开发中，大数通常用于保存时间戳、分数和跟踪进度。 BigInt 的使用确保了此类值的准确表示
    分布式系统：分布式系统需要唯一身份才能准确执行。由于 BigInt 值是无限的，因此它们可用于生成标识符和密钥
    `,
  },
  {
    title: "JS --- 66.基本数据类型和引用数据类型的区别",
    content: `
    1.基本数据类型存储在栈内存中
    2.数据存储时，基本数据类型在变量中存的是值，引用数据类型在变量中存储的是空间地址
    `,
  },
  {
    title: "JS --- 67.什么是堆栈内存",
    content: `
    1.堆内存和栈内存是浏览器形成的两个虚拟内存
    2.栈内存主要是用来存储基本数据的值，栈内存是一种简单的存储，但是存储的数据都是有范围上线的，一旦超过，就会造成栈溢出
    3.堆内存主要是用来存储引用数据类型的
    堆内存：存储引用类型，对象类型就是键值对，函数就是代码字符串
    堆内存释放：将引用类型的空间地址变量赋值成null，或者没有变量占用堆内存了，浏览器就会释放掉这个地址
    栈内存：提供代码执行的环境和存储基本类型值
    栈内存释放：一般当函数执行完后，函数的私有作用域就会被释放掉
    `,
  },
  {
    title: "JS --- 68.isNaN() 和 Number.isNaN()的区别是什么",
    content: `
    NaN（Not a Number）有一个非常特殊的特性，NaN不等于其本身，也不等于任何
    isNaN：先尝试转换为数字，如果隐式转换为Number类型失败，就会返回NaN
    Numnber.isNaN()：直接判断是否为NaN
    `,
  },
  {
    title: "JS --- 69.讲讲JS/ES6中的数组方法",
    content: `
    数组和字符串方法：toString()，toLocalString()，join()
    数组增删（前增后增，前删后删）的方法：pop() 和 push()，shift() 和 unshift()
    数组排序方法：reverse() 和 sort()
    数组连接方法：concat() 不影响原数组
    数组截取方法：slice() 不影响原数组
    数组插入方法：splice()，影响原数组
    数组通过索引查找方法：indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach()
    数组归并方法：reduce() 和 reduceRight() 方法
    数组判断是否存在值：includes()
    `,
  },
];
