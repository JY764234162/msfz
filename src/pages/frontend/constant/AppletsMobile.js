/*
 * @Author: whq
 * @Date: 2024-04-08 09:01:16
 * @LastEditTime: 2024-04-08 16:56:49
 * @LastEditors: whq
 * @Description:
 * @FilePath: \优铸科技c:\Users\wangh\Desktop\项目\面试\面试题\AppletsMobile.js
 */
export default [
  {
    title: "小程序 --- 1. 小程序与H5的区别",
    content: `
    运行环境方面
    从运行环境方面开看，H5 的宿主环境是浏览器，只要有浏览器，就可以使用，包括APP中的 web-view 组件，以及小程序提供的 web-view 组件
    小程序就不一样了，它运行于特定的移动软件平台 (Wechat / 支付宝 / 字节跳动 / 百度 / QQ 等)
    拿微信小程序来说，它是基于浏览器内核重构的内置解析器，它并不是一个完整的浏览器，官方文档中重点强调了脚本内无法使用浏览器中常用的 window 对象和 document 对象，就是没有 DOM 和 BOM 的相关的 API，这一条就干掉了 JQ 和一些依赖于 BOM 和 DOM 的NPM包
    运行机制方面
    H5 的运行就是一个网页的运行,小程序还是以微信小程序举例
    一.启动
      1.如果用户已经打开过某小程序，在一定时间内再次打开该小程序，此时无需重新启动，只需将后台的小程序切换到前台，整个过程就是所谓的 热启动
      2.如果用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，就是 冷启动
    二.销毁
      1.当小程序进入后台一定时间，或系统资源占用过高，或者是你手动销毁，才算真正的销毁
    系统权限方面
    H5最被诟病的地方在哪？系统权限不够，比如网络通信状态、数据缓存能力、通讯录、或调用硬件的，如蓝牙功能等等一些APP有的功能，H5就没有这些系统权限，因为它重度依赖浏览器能力
    依旧是微信小程序举例，微信客户端的这些系统级权限都可以和微信小程序无缝衔接，官方宣称拥有 Native App 的流畅性能
    开发语言方面
    H5 开发大家都知道，标准的 HTML、CSS、JavaScript ，万变不离其三剑客
    小程序不同， (Wechat / 支付宝 / 字节跳动 / 百度 / QQ 等)不同的小程序都有自己定义独特的语言
    最常用的微信小程序，自定义的 WXML、WXSS，WXML 中全部是微信自定义的标签，WXSS、JSON 和 JS 文件中的写法都稍有限制，官方文档中都有明确的使用介绍，虽容易上手，但还是有区别的
    开发成本方面
    还是先说 H5，开发一个 H5 ，我们要考虑什么，首先开发工具 ( vscode/webstorm/atom/sublim等 )，其次是开发框架 ( Vue/React/Angular等 )， 接着考虑模块化工具 ( Webpack/Gulp/Parcel等 )，再然后UI库、各种包的选择，更是数不胜数，还要考虑兼容问题，成本还是比较高的
    这块小程序的话不用再去考虑浏览器兼容性，拿微信小程序举例子，没有兼容性问题后，只需要看着文档在微信开发工具里写就行了，小程序还独立出来了很多原生APP的组件，在H5需要模拟才能实现的功能，小程序里可以直接调用组件，都是封装好的，你也可以使用转译框架来写小程序，也有很多UI库选择，单论开发成本的话，小程序应该是胜出的
    不过小程序再简单也是需要学习过程的，坑肯定也多，因为它还在逐步变强的过程中嘛，毕竟是和H5不一样的东西
    更新机制方面
    H5 的话想怎么更新就怎么更新，更新后抛开CDN/浏览器缓存啥的，基本上更新结束刷新就可以看到效果
    小程序不同，还是微信举例，微信小程序更新啥的是需要通过审核的
    而且开发者在发布新版本之后，无法立刻影响到所有现网用户，要在发布之后 24 小时之内才下发新版本信息到用户
    小程序每次 冷启动 时，都会检查有无更新版本，如果发现有新版本，会异步下载新版本代码包，并同时用客户端本地包进行启动，所以新版本的小程序需要等下一次 冷启动 才会应用上，当然微信也有 wx.getUpdateManager 可以做检查更新
    渲染机制方面
    H5就是 web 渲染，浏览器渲染
    微信小程序的宿主环境是微信，宿主环境为了执行小程序的各种文件：wxml文件、wxss文件、js文件，提供了双线模型 ，什么是双线程模型呢
    一.小程序的渲染层和逻辑层分别由2个线程管理
    1.渲染层：界面渲染相关的任务全都在 WebView 线程里执行，一个小程序存在多个界面，所以渲染层存在多个 WebView线程
    2.逻辑层：一个单独的线程执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码，就是通过图中的 JsCore 线程来运行 JS 脚本
    3.这两个线程都会经过微信客户端( Native )中的 WeixinJsBridage 进行中转通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理二.小程序的渲染逻辑
      1.在渲染层将 WXML 先转换为 js 对象也就是虚拟 DOM
      2.在逻辑层将虚拟 DOM 对象生成真实 DOM 树，交给渲染层渲染
      3.当视图有数据需更新时，逻辑层调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到渲染层
      4.经过对比前后差异 ( diff算法 )，把差异应用在真实的 Dom 树上，渲染出正确的 UI 界面完成视图更新
    虽然小程序是通过 Native 原生渲染的，但是小程序也支持web渲染，就是 web-view 组件，在 web-view 中加载 H5 页面，而我们开发小程序时，通常会使用 hybrid 的方式，根据具体情况选择部分功能用小程序原生的代码来开发，部分功能通过 web-view 加载 H5 页面来实现，Native 与 Web 渲染 混合使用，实现项目最优解
    `,
  },
  {
    title: "小程序 --- 2. 对小程序的理解和优缺点",
    content: `
    2017年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务
    截至目前，小程序已经成为国内前端的一个重要业务，跟 Web 和手机 App 有着同等的重要性
    小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用
    也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载
    注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序
    ⼩程序并⾮凭空冒出来的⼀个概念，当微信中的 WebView 逐渐成为移动 Web的⼀个重要⼊⼝时，微信就有相关的 JS-SDK
    JS-SDK 解决了移动⽹⻚能⼒不⾜的问题，通过暴露微信的接⼝使得 Web 开发者能够拥有更多的能⼒，然⽽在更多的能⼒之外，JS-SDK的模式并没有解决使⽤移动⽹⻚遇到的体验不良的问题
    因此需要设计⼀个⽐较好的系统，使得所有开发者在微信中都能获得⽐较好的体验：
    快速的加载
    更强⼤的能⼒
    原⽣的体验
    易⽤且安全的微信数据开放
    ⾼效和简单的开发
    这些是JS-SDK做不到的，需要设计一个全新的小程序系统
    对于小程序的开发，提供一个简单、高效的应用开发框架和丰富的组件及API，帮助开发者开发出具有原生体验的服务
    其中相比H5，小程序与其的区别有如下：
    运⾏环境：⼩程序基于浏览器内核重构的内置解析器
    系统权限：⼩程序能获得更多的系统权限，如⽹络通信状态、数据缓存能⼒等
    渲染机制：⼩程序的逻辑层和渲染层是分开的
    小程序可以视为只能用微信打开和浏览的H5，小程序和网页的技术模型是一样的，用到的 JavaScript 语言和 CSS 样式也是一样的，只是网页的 HTML 标签被稍微修改成了 WXML 标签
    因此可以说，小程序页面本质上就是网页
    优缺点
    优点：
    随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体
    流量大，易接受：小程序借助自身平台更加容易引入更多的流量
    安全
    开发门槛低
    降低兼容性限制
    缺点：
    用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%
    体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序
    受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控
    `,
  },
  {
    title: "小程序 --- 3. 说说提高微信小程序的应用速度的手段有哪些？",
    content: `
    产生原因小程序首次启动前，微信会在小程序启动前为小程序准备好通用的运行环境，如运行中的线程和一些基础库的初始化
    然后才开始进入启动状态，展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：
    下载小程序代码包
    加载小程序代码包
    初始化小程序首页
    下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包
    处理手段
    围绕上图小程序的启动流程， 我们可以从加载、渲染两个纬度进行切入：
    #加载
    提升体验最直接的方法是控制小程序包的大小，常见手段有如下：
    代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项
    及时清理无用的代码和资源文件
    减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限
    并且可以采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载
    当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包
    渲染方面
    关于微信小程序首屏渲染优化的手段如下：
    请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据
    尽量减少不必要的https请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地
    可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--> 详情页），没有数据的模块可以进行骨架屏的占位
    在微信小程序中，提高页面的多次渲染效率主要在于正确使用setData：
    不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用
    数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据
    与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下
    除此之外，对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新
    各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用
    总结
    小程序启动加载性能：
    控制代码包的大小
    分包加载
    首屏体验（预请求，利用缓存，避免白屏，及时反馈
    小程序渲染性能：
    避免不当的使用setData
    使用自定义组件
    `,
  },
  {
    title: "小程序 --- 4. 小程序的安卓版和ios版是怎么开发出来",
    content: `
    小程序开发基于html、css、javascript，与web开发一样具有跨平台特性，一次开发即可在安卓和iOS等平
    台访问，但与普通web开发不同，小程序运行环境并不是浏览器，而是依附于各自的软件App，如微信小
    程序必须在微信中访问，支付宝小程序必须在支付宝中访问等，小程序的开发流程也有所不同，需要经
    过申请小程序帐号、安装小程序开发者工具、配置项目、开发、调试、上线发布等过程方可完成
    `,
  },
  {
    title: "小程序 --- 5. 小程序生命周期",
    content: `
    onReady 生命周期函数--监听页面初次渲染完成
    onShow 生命周期函数--监听页面显示
    onHide 生命周期函数--监听页面隐藏
    onUnload 生命周期函数--监听页面卸载
    onPullDownRefresh 页面相关事件处理函数--监听用户下拉动作
    onReachBottom 页面上拉触底事件的处理函数
    onShareAppMessage 用户点击右上角转发
    onPageScroll 页面滚动触发事件的处理函数
    onTabItemTap 当前是 tab 页时，点击 tab 时触发
    `,
  },
  {
    title: "小程序 --- 6. 小程序的兼容问题有哪些",
    content: `
    遇到的如下：
    1，ios下的zIndex层级问题，主要发生在iphone7和iphoneX下 绝对定位必须有一个共同的父元素。
    2，左右边框不生效 当边框的宽度设置为奇数的时候，可能会不生效 解决方法：将宽度设置为偶数
    的时候，在ios下就可以解决
    3，还有尽量不要用margin-bottom ，当元素是在整个页面的最底部的时候，在ios下可能marginbottom会失效，所以建议，都使用padding-bottom
    new Date跨平台兼容性问题
    在Andriod使用new Date(“2018-05-30 00:00:00”)木有问题，但是在ios下面识别不出来。
    因为IOS下面不能识别这种格式，需要用2018/05/30 00:00:00格式。可以使用正则表达式对做字符串替
    换，将短横替换为斜杠。var iosDate= date.replace(/-/g, '/');。
    wx.getUserInfo()接口更改问题
    微信小程序最近被吐槽最多的一个更改，就是用户使用wx.getUserInfo（开发和体验版）时不会弹出授
    权，正式版不受影响。现在授权方式是需要引导用户点击一个授权按钮，然后再弹出授权。
    `,
  },
  {
    title: "小程序 --- 7. 小程序的登录流程",
    content: `
    首次登录
    调用小程序api接口 wx.login() 获取 临时登录凭证code ，这个code是有过期时间的.
    将这个 code 回传到开发者服务器（就是请求开发者服务器的登录接口，通过凭证进而换取用
    户登录态信息，包括用户的唯一标识（openid）及本次登录的会话密钥（session_key）等）
    拿到开发者服务器传回来的会话密钥（session_key）之后，前端需要保存起来.
    wx.setStorageSync('sessionKey', 'value')
    再次登录的时候，就要判断存储的session_key是否过期了
    获取缓存中的session_key， wx.getStorageSync('sessionKey')
    如果缓存中存在session_key，那么调用小程序api接口 wx.checkSession() 来判断登录态是
    否过期，回调成功说明当前 session_key 未过期，回调失败说明 session_key 已过期。登录态过
    期后前端需要再调用 wx.login()获取新的用户的code，然后再向开发者服务器发起登录请求.
    一般在项目开发，开发者服务器也会对用户的登录态做过期限制，所以这时在判断完微信服务
    器中登录态如果没有过期之后还要判断开发者服务器的登录态是否过期。（请求开发者服务器
    给定的接口进行请求判断就好）
    `,
  },
  {
    title: "小程序 --- 8. 小程序如果版本更新了怎么通知用户",
    content: `
    当小程序发布新的版本后，用户如果之前访问过该小程序，通过已打开的小程序进入（未手动删除），
    则会弹出提示，提醒用户更新新的版本。用户点击确定就可以自动重启更新，点击取消则关闭弹窗，不
    再更新.
    核心步骤:
    打开小程序, 检查小程序是否有新版本发布
    小程序有新版本，则静默下载新版本，做好更新准备
    新的版本已经下载好，调用 applyUpdate 应用新版本并重启小程序
    更新版本的模拟测试
    微信开发者工具上可以通过「编译模式」下的「下次编译模拟更新」开关来调试.
    点击编译模式设置下拉列表，然后点击“添加编译模式”，在自定义编译条件弹窗界面，点击下次编
    译时模拟更新，然后点击确定，重新编译就可以了.
    注: 需要注意的是，这种方式模拟更新一次之后就失效了，后边再测试仍需要对这种编译模式进行
    重新设置才可以.
    `,
  },
  {
    title: "小程序 --- 9. 小程序嵌入H5页面怎么做",
    content: `
    解决方式 ：web-view
    webview 指向网页的链接。可打开关联的公众号的文章，其它网页需登录小程序管理后台配置业务域
    名。
    具体实现步骤:
    登陆小程序管理后台, 配置服务器域名( h5页面所在的域名 )
    在小程序里面嵌入h5
    在小程序里面定义一个你想要的H5入口
    新建一个页面，放置 webview , src指向h5网页的链接.
    注: 实际开发中在h5页面中有可能需要向小程序发送消息, 实现h5页面和小程序页面的通信
    需要使用postMessage向小程序发送消息, 在h5中postMessage 注意，key必须叫做data,否则取不到
    `,
  },
  {
    title: "小程序 --- 10. 小程序的wxss和css有哪些不一样的地方",
    content: `
    WXSS 和 CSS 类似，不过在 CSS 的基础上做了一些补充和修改
    尺寸单位 rpx
    rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。 如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。
    换算成px 就是实际尺寸/2 = px;
    使用 @import 标识符来导入外联样式。@import 后跟需要导入的外联样式表的相对路径，用;表示语句结束
    @import '../plugins/wxParse/wxParse.wxss';
    `,
  },
  {
    title: "小程序 --- 11. 小程序页面间传递数据的方法",
    content: `
    URL 参数传递：可以通过在跳转时将数据作为 URL 参数传递给目标页面。目标页面可以通过 getCurrentPages() 方法获取到当前页面的实例，并从中获取到传递过来的参数。
    全局变量：可以将数据保存在小程序的全局变量中，然后在目标页面中直接访问这些全局变量。
    Storage API：可以使用小程序提供的 Storage API 将数据存储在本地缓存中，然后在目标页面中读取这些数据。常用的方法包括 wx.setStorage() 和 wx.getStorage()。
    事件总线（EventBus）：可以使用事件总线模式，在页面间建立事件订阅和发布机制，一个页面发布事件，另一个页面订阅事件，实现页面间的数据传递。
    页面栈：小程序的页面栈提供了一种简单的页面间通信机制。通过在页面 A 中使用 wx.navigateTo() 或 wx.redirectTo() 打开页面 B，然后在页面 B 关闭时返回数据给页面 A。
    组件通信：如果页面中包含多个组件，可以通过组件间的事件传递机制来实现数据的传递。
    `,
  },
  {
    title: "小程序 --- 12. 小程序有几个文件",
    content: `
    WXML： 微信自己定义的一套组件
    WXSS :    用于描述 WXML 的组件样式
    js :   逻辑处理
    json  :  小程序页面配置`,
  },
  {
    title: "小程序 --- 13. 微信小程序与vue区别",
    content: `
    生命周期不一样，微信小程序生命周期比较简单
    数据绑定也不同，微信小程序数据绑定需要使用{{}}，vue 直接:就可以 显示与隐藏元素，vue中，使用 v-if和 v-show控制元素的显示和隐藏，小程序中，使用wx-if和hidden 控制元素的显示和隐藏
    事件处理不同，小程序中，全用 bindtap(bind+event)，或者
    catchtap(catch+event)绑定事件,vue：使用v-on:event 绑定事件，或者使用@event绑定事件
    数据双向绑定也不也不一样在 vue中,只需要再表单元素上加上 v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是 vue非常 nice的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个 data中声明的变量。
    `,
  },
  {
    title: "小程序 --- 14. 微信小程序的优劣势",
    content: `
    优势：
    1、无需下载，通过搜索和扫一扫就可以打开。
    2、良好的用户体验：打开速度快。
    3、开发成本要比App要低。
    4、安卓上可以添加到桌面，与原生App差不多。
    5、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程，不能通过审查的小程序是无法发布到线上的。
    缺点：
    1、限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。
    2、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。
    3、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。
    4、依托于微信，无法开发后台管理功能。
    `,
  },
  {
    title: "小程序 --- 15. 小程序的双向绑定和Vue哪里不一样。",
    content: `
    小程序 直接使用this.data.key = value  是  不能更新到视图当中的。
    必须使用  this.setData({  key ： value  })  来更新值。
    `,
  },
  {
    title: "小程序 --- 16. bindtap和catchtap的区别是什么",
    content: `
    相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分
    不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的
    `,
  },
  {
    title: "小程序 --- 17. 说说微信小程序的实现原理",
    content: `
    在小程序开发中，渲染线程和脚本是互斥的，即长时间的脚本运行可能会导致页面失去响应，这是因为JS是单线程的。小程序采用Hybrid渲染方式，将视图层和逻辑层分开，视图层使用WebView进行渲染，逻辑层运行在JSCore中，实现了双线程同时运行。
    通信方面，小程序的渲染层和逻辑层之间采用线程间通信。在逻辑层发生数据变更时，通过宿主环境提供的setData方法将数据从逻辑层传递到渲染层，再根据前后差异更新视图。事件分发处理也经过特殊处理，所有事件被拦截后交给逻辑层的JavaScript进行处理。
    小程序的运行机制分为冷启动和热启动两种情况。冷启动是指首次打开或者小程序被微信主动销毁后再次打开的情况，而热启动是指用户已经打开过小程序，再次打开时无需重新启动，只需将后台态的小程序切换到前台。
    需要注意的是，小程序没有重启的概念，当进入后台一段时间后会被微信主动销毁，也可能由于内存警告而被销毁。开发者发布新版本后，无法立即影响到所有用户，而是在下一次冷启动时应用新版本。
    `,
  },
  {
    title: "小程序 --- 18. 小程序什么时候会主动销毁？",
    content: `
    小程序在进入后台之后，客户端会帮我们在一定时间内维持我们的一个状态，超过五分钟后，会被微信主动销毁.
    官方也没有明确说明 什么时候销毁， 在不同机型表现也不一样，
    2019年开发时：时间官方文档没有说明，但是经过询问一般指5分钟内
    2020年开发时：时间官方文档没有说明，实测安卓没有固定时间，内存足够情况下，有时候一天了还在，有时候几分钟就没了。
    `,
  },
  {
    title:
      "小程序 --- 19. 谈谈你对uni-app的理解/描述一下Uniapp的工作原理/描述一下在Uniapp中如何实现跨平台开发",
    content: `
    uni-app是一个使用Vue.js开发所有前端应用的框架，开发者编写一套代码，可以发布到IOS、Android、Web（响应式）、以及各种小程序、快应用等多个平台。
    uniapp真正做到一套代码多端发行，支持原生代码混写和原生sdk集成。
    运行体验更好。组件、api与微信小程序一致，兼容 Weex 原生渲染。
    通用技术栈，学习成本更低。Vue的语法，微信小程序的api，对于前端开发人员来说更容易上手。
    开放生态，组件更丰富。支持通过npm安装第三方包；支持微信小程序自定义组件及sdk；兼容 mpvue 组件及项目；app端支持与原生混合编码；
    `,
  },
  {
    title: "小程序 --- 20. uni中如何为不同的平台设置不同的代码",
    content: `
    通过条件注释来为不同平台设置不同的代码：
    条件注释的作用：实现跨端兼容
    使用方法：以 #ifdef 或 #ifndef 加平台代值开头，以 #endif 结尾
    #ifdef：if defined 如果是xx平台则运行代码块 #ifndef：if not defined 如果不是xx平台才运行代码块
    H5 H5
    MP-WEIXIN 微信小程序
    APP-PLUS app
    MP 所有小程序
    `,
  },
  {
    title:
      "小程序 --- 21. uni-app 在非h5端上运行为什么要在架构上分为逻辑层和视图层？",
    content: `
    主要原因是性能。web端都运行在webview里，js运算和界面渲染会抢资源导致卡顿，而小程序和app，逻辑层都独立为了单独的 js 引擎，渲染层仍然是webvbiew（app也支持原生渲染）。所以在小程序和app上不支持window，dom等API（app可以在渲染层操作window,dom）
    `,
  },
  {
    title: "小程序 --- 22. 开发uni-app遇到的坑",
    content: `
    上传图片
    小程序时必须要写header:{“Content-Type”: “multipart/form-data”}, h5是必须省略
    uni-app h5 端的ios图片不能加载问题
    uni-app h5端 ios只能加载https的图片
    uni-app 使用deep 穿透微信小程序生效 h5无作用
    需要在methods同级下加一个 ：
    options: { styleIsolation: ‘shared’ },
    uni-app post请求如何传递数组 参数
    在开发中我们接口上传图片是post请求 无法传递一个数组 解决方法如下
    我们可以把数据转换成字符串 然后拼接到请求地址后后面
    拼接字符串格式：image[]=arr[0]&image[]=arr[1]
    `,
  },
  {
    title: "小程序 --- 23. PC端与移动端在UI设计方面有什么区别",
    content: `
    1、PC端在开发过程中考虑的是浏览器兼容性移动端开发面试，移动端开发中考虑的是手机兼容性问题，做移动端开发，更多考虑的是手机分辨率的自适应和不同手机操作系统的略微差异化；
    2、在部分事件的处理上，移动端自然是偏向于触屏的，另外包括移动端弹出的手机键盘该如何处理，这样的问题在PC上肯定不会遇到，但在移动端，如果移动端开发面试你没有经验，处理起来是相当麻烦的；
    3、布局上，移动端开发是要做到页面布局自适应的，而PC端页面布局的比例会相对固定；
    4、在动画效果处理上，PC端要考虑IE的兼容性，通常用JS做动画的通用性会好一些，但相比CSS3却牺牲了较大的性能，而在手机端，如果要做一些动画、特效等，第一选择肯定是CSS3，既简单，效率又高。
  `,
  },
  {
    title: "小程序 --- 24. 什么是响应式设计？你如何实现响应式设计？",
    content: `
    是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整
    响应式网站常见特点
    同时适配PC + 平板 + 手机等
    标签导航在接近手持终端设备时改变为经典的抽屉式导航
    网站的布局会根据视口来调整模块的大小和位置
    响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有meta声明viewport
    第一种就是通过媒体查询的方式 css中 @Media，可以针对不同的媒体类型定义不同的样式,例如当视口在375px - 600px之间，设置特定字体大小18px
    @media screen (min-width: 375px) and (max-width: 600px) {
      body {
        font-size: 18px;
      }
    }
    第二种就是通过百分比单位 " % " 来实现响应式的效果
    比如当浏览器的宽度或者高度发生变化时，通过百分比单位，可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果
    height、width属性的百分比依托于父标签的宽高，但是其他盒子属性则不完全依赖父元素：
    子元素的top/left和bottom/right如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度/宽度
    子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。
    子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width
    border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度
    可以看到每个属性都使用百分比，会照成布局的复杂度，所以不建议使用百分比来实现响应式
    第三种 vw/vh,vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度。 任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一
    第四种rem是相对于根元素html的font-size属性，默认情况下浏览器字体大小为16px，此时1rem = 16px
    可以利用前面提到的媒体查询，针对不同设备分辨率改变font-size的值无论设备可视窗口如何变化，始终设置rem为width的1/10，实现了百分比布局
    除此之外，我们还可以利用主流UI框架，如：element ui、antd提供的栅格布局实现响应式
    响应式设计实现通常会从以下几方面思考：
    弹性盒子（包括图片、表格、视频）和媒体查询等技术
    使用百分比布局创建流式布局的弹性UI，同时使用媒体查询限制元素的尺寸和内容变更范围
    使用相对单位使得内容自适应调节
    选择断点，针对不同断点实现不同布局和内容展示
    总结
    响应式布局优点可以看到：
    面对不同分辨率设备灵活性强
    能够快捷解决多设备显示适应问题
    缺点：
    仅适用布局、信息、框架并不复杂的部门类型网站
    兼容各种设备工作量大，效率低下
    代码累赘，会出现隐藏无用的元素，加载时间加长
    其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果
    一定程度上改变了网站原有的布局结构，会出现用户混淆的情况`,
  },
  {
    title: "小程序 --- 25. 为什么移动端click会有300毫秒延迟？",
    content: `
    因为移动端浏览器会有一些默认的行为，比如双击缩放、双击滚动。这些行为尤其是双击缩放，主要是为桌面网站在移动端的浏览体验设计的。而在用户对页面进行操作的时候，移动端浏览器会优先判断用户是否要触发默认的行为
    `,
  },
  {
    title: "小程序 --- 26. 为什么安卓浏览器看背景图片，有些设备会模糊",
    content: `
    因为手机分辨率太小，如果按照分辨率来显示网页，字会非常小，安卓手机devicePixoRadio比较乱，有1.5的，有2的也有3的。想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况下都是2倍的），或者指定background-size:contain;都可以。
    用-webkit-min-device-pixel-ratio可以做到不同倍数不同尺寸的图片
    `,
  },
  {
    title: "小程序 --- 27. 如何防止手机中页面放大和缩小",
    content: `
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    `,
  },
  {
    title: "小程序 --- 28. 如何解决上下拉动滚动条时出现卡顿的现象？",
    content: `
    body{
      -webkit-overflow-scrolling:touch;
      overflow-scrolling:touch;
    }
    Android3+和iOSi5+支持CSS3的新属性为overflow-scrolling
    `,
  },
  {
    title: "小程序 --- 29. 如何解决长时间按住页面闪退的现象？",
    content: `element{
      -webkit-touch-callout:none;
    }
      `,
  },
  {
    title: "小程序 --- 30. 移动端为什么会有一像素问题？如何解决？",
    content: `
    移动端出现一像素问题的主要原因是由于不同分辨率的设备渲染一像素边框时可能会出现模糊或者多像素渲染的情况。为了解决这个问题，可以采取以下几种方法：
    使用伪类元素实现边框效果，并通过媒体查询操控transform: scale来适配不同分辨率。
    使用border-image来代替border样式，通过设置border-image的方式来达到一像素边框的效果。
    使用viewport + rem 的方式，通过动态设置meta标签的内容来适配不同的分辨率，然后使用rem作为单位来定义边框的大小。
    引入border.css等专门解决一像素边框问题的库或者样式文件。
    `,
  },
  {
    title: "小程序 --- 31. React Native与ReactJS有什么不同？",
    content: `
    React Native是一个JavaScript框架，由Facebook开发，以满足日益增长的移动应用开发的需求。它是开源的，基于JavaScript的。它被设计为用可重复使用的组件构建本地移动应用程序。它使用了大量的ReactJS组件，但在不同的设备上以原生方式实现它们。它调用Objective-C（用于iOS）和Java（用于Android）中的本地渲染API。
    ReactJS也是由Facebook开发的。它是一个开源的JavaScript库，用于为移动和网络应用开发响应式的用户界面。它有一个可重复使用的组件库，旨在帮助开发者为他们的应用程序建立基础。
    让我们来看看它们的一些主要区别。
    语法。React Native和ReactJS都使用JSX，但ReactJS使用HTML标签，而React Native不使用。
    导航。React Native使用自己的内置导航库，而ReactJS使用react-router。
    动画。ReactJS使用CSS动画。React Native使用其动画API。
    DOM。ReactJS使用部分刷新的虚拟DOM。React Native在渲染UI组件时需要使用其本地API。
    用法。ReactJS主要用于Web应用开发，而React Native则专注于移动应用。
`,
  },
  {
    title:
      "小程序 --- 32. React Native相对于原生的ios和Android有哪些优势？/与原生应用程序开发相比，React Native 的优势/为什么选择RN",
    content: `
    1.性能媲美原生APP
    2.使用JavaScript编码，只要学习这一种语言 
    3.绝大部分代码安卓和IOS都能共用
    4.组件式开发，代码重用性很高 
    5.跟编写网页一般，修改代码后即可自动刷新，不需要慢慢编译，节省很多编译等待时间
    6.支持APP热更新，更新无需重新安装APP
    缺点： 内存占用相对较高 版本还不稳定，一直在更新，现在还没有推出稳定的1.0版本
    1 优势
    性能方面媲美原生App。
    绝大部分代码同时适用IOS/Android，一套代码两套系统适用。
    使用Javascript编码，上手容易。
    组件式开发，易于管理维护，代码复用率高。
    代码更改后会自动刷新，节省等待时间。
    支持热更新，更新无需重新安装App。
    2 劣势
    RN组件库不全，第三方组件库也不全，当遇到某些特殊功能，需要花费大量时间、精力完成；性能方面也无法媲美原生，还是会有一些损耗，特别是大数据交换时；
    系统适配方面， IOS版本略好，android发展较慢；
    编程方面， ios和android代码并非通用，有可能需要维护两套代码或者在代码中做一些条件判断或编译；
    开发人员还是需要会原生开发，不然自定义组件无法编码；
    开发复杂应用必须精通原生开发，开发效率并不比原生开发的熟手快。很多问题（包括兼容性问题解决）任然需要原生开发。
    升级RN版本或需要大动干戈，尤其向下兼容不好；
    `,
  },
];
